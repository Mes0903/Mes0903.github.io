<!doctype html>
<html lang="en-US" data-theme="light">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <meta name="generator" content="VuePress 2.0.0-rc.20" />
    <meta name="theme" content="VuePress Theme Hope 2.0.0-rc.73" />
    <style>
      :root {
        --vp-c-bg: #fff;
      }

      [data-theme="dark"] {
        --vp-c-bg: #1b1b1f;
      }

      html,
      body {
        background: var(--vp-c-bg);
      }
    </style>
    <script>
      const userMode = localStorage.getItem("vuepress-theme-hope-scheme");
      const systemDarkMode =
        window.matchMedia &&
        window.matchMedia("(prefers-color-scheme: dark)").matches;

      if (userMode === "dark" || (userMode !== "light" && systemDarkMode)) {
        document.documentElement.setAttribute("data-theme", "dark");
      }
    </script>
    <meta property="og:url" content="https://mes0903.github.io/Cpp-Miner/Miner_main/Structured_Binding/"><meta property="og:site_name" content="Mes's Blog"><meta property="og:title" content="礦坑系列 ── 結構化綁定 Structured Binding Declaration"><meta property="og:description" content="礦坑系列首頁：首頁 hackmd 版首頁：首頁 前言 Structured binding declaration 是 C++17 加入的一個新特性，它讓我們能夠更簡單地去處理多個回傳值或多變數的情況，通常會在要接 tuple_like 的容器或 Struct 回傳值時搭配 auto 來使用 我盡量將原裡理解並寫在了「介紹及原理」的部分，有些部分是翻譯..."><meta property="og:type" content="article"><meta property="og:locale" content="en-US"><meta property="article:tag" content="C++ Miner-main"><meta property="article:published_time" content="2021-04-01T00:00:00.000Z"><script type="application/ld+json">{"@context":"https://schema.org","@type":"Article","headline":"礦坑系列 ── 結構化綁定 Structured Binding Declaration","image":[""],"datePublished":"2021-04-01T00:00:00.000Z","dateModified":null,"author":[{"@type":"Person","name":"Mes","url":"https://mes0903.github.io"}]}</script><link rel="icon" href="/flame.ico"><title>礦坑系列 ── 結構化綁定 Structured Binding Declaration | Mes's Blog</title><meta name="description" content="礦坑系列首頁：首頁 hackmd 版首頁：首頁 前言 Structured binding declaration 是 C++17 加入的一個新特性，它讓我們能夠更簡單地去處理多個回傳值或多變數的情況，通常會在要接 tuple_like 的容器或 Struct 回傳值時搭配 auto 來使用 我盡量將原裡理解並寫在了「介紹及原理」的部分，有些部分是翻譯...">
    <link rel="preload" href="/assets/style-yygi0ZLI.css" as="style"><link rel="stylesheet" href="/assets/style-yygi0ZLI.css">
    <link rel="modulepreload" href="/assets/app-CHKuTo5H.js"><link rel="modulepreload" href="/assets/index.html-C250RXCV.js"><link rel="modulepreload" href="/assets/plugin-vue_export-helper-DlAUqK2U.js">
    <link rel="prefetch" href="/assets/index.html-LGgEKxzc.js" as="script"><link rel="prefetch" href="/assets/index.html-CSLOHb4p.js" as="script"><link rel="prefetch" href="/assets/index.html-BFguPUtB.js" as="script"><link rel="prefetch" href="/assets/index.html-DWTgPFKZ.js" as="script"><link rel="prefetch" href="/assets/index.html-CFZHtUbl.js" as="script"><link rel="prefetch" href="/assets/index.html-DZzhtp6D.js" as="script"><link rel="prefetch" href="/assets/index.html-Jpy4XiDy.js" as="script"><link rel="prefetch" href="/assets/index.html-BO5GbDAB.js" as="script"><link rel="prefetch" href="/assets/index.html--r05a-tq.js" as="script"><link rel="prefetch" href="/assets/index.html-DNvlzXIF.js" as="script"><link rel="prefetch" href="/assets/index.html-BWiUYrxC.js" as="script"><link rel="prefetch" href="/assets/index.html-B5XPrdYf.js" as="script"><link rel="prefetch" href="/assets/index.html-7__A5OVN.js" as="script"><link rel="prefetch" href="/assets/index.html-D3YabxrV.js" as="script"><link rel="prefetch" href="/assets/index.html-b_TwmRfE.js" as="script"><link rel="prefetch" href="/assets/index.html-BkqAGQfa.js" as="script"><link rel="prefetch" href="/assets/index.html-BoDMO0Vr.js" as="script"><link rel="prefetch" href="/assets/index.html-AV1bIQUu.js" as="script"><link rel="prefetch" href="/assets/index.html-BtNfXwnF.js" as="script"><link rel="prefetch" href="/assets/index.html-DL_-L8CA.js" as="script"><link rel="prefetch" href="/assets/index.html-E3CCfcX6.js" as="script"><link rel="prefetch" href="/assets/index.html-Ct1jfspJ.js" as="script"><link rel="prefetch" href="/assets/index.html-vtZI25DR.js" as="script"><link rel="prefetch" href="/assets/index.html-Jh1Jmh_7.js" as="script"><link rel="prefetch" href="/assets/index.html-Ci_0Sl-Z.js" as="script"><link rel="prefetch" href="/assets/index.html-BXjrkLaT.js" as="script"><link rel="prefetch" href="/assets/index.html-BedI-lkk.js" as="script"><link rel="prefetch" href="/assets/index.html-DisBFNeq.js" as="script"><link rel="prefetch" href="/assets/index.html-hKTQI-y3.js" as="script"><link rel="prefetch" href="/assets/index.html-Ke_RRlO6.js" as="script"><link rel="prefetch" href="/assets/index.html-BtVkLu4p.js" as="script"><link rel="prefetch" href="/assets/index.html-vSogmX4W.js" as="script"><link rel="prefetch" href="/assets/index.html-58clDljP.js" as="script"><link rel="prefetch" href="/assets/index.html-Ccxud35E.js" as="script"><link rel="prefetch" href="/assets/index.html-CGSm_3Pq.js" as="script"><link rel="prefetch" href="/assets/index.html-Rn7di6LV.js" as="script"><link rel="prefetch" href="/assets/index.html-DPYKno7b.js" as="script"><link rel="prefetch" href="/assets/index.html-FAgDUtaE.js" as="script"><link rel="prefetch" href="/assets/index.html-DHOSxEJS.js" as="script"><link rel="prefetch" href="/assets/index.html-cqGEGsSW.js" as="script"><link rel="prefetch" href="/assets/index.html-D1syyBWG.js" as="script"><link rel="prefetch" href="/assets/index.html-B8GQK1Zc.js" as="script"><link rel="prefetch" href="/assets/index.html-DL0woI-x.js" as="script"><link rel="prefetch" href="/assets/index.html-Dnx2kZHf.js" as="script"><link rel="prefetch" href="/assets/index.html-DiCzZlOr.js" as="script"><link rel="prefetch" href="/assets/index.html-BppHnavO.js" as="script"><link rel="prefetch" href="/assets/index.html-CQOoWUYw.js" as="script"><link rel="prefetch" href="/assets/index.html-B_8lpD44.js" as="script"><link rel="prefetch" href="/assets/index.html-CJSFpdKD.js" as="script"><link rel="prefetch" href="/assets/404.html-CcWIjXsR.js" as="script"><link rel="prefetch" href="/assets/index.html-D3NcHajj.js" as="script"><link rel="prefetch" href="/assets/index.html-Bqf8k3Yy.js" as="script"><link rel="prefetch" href="/assets/index.html-BrDTF34D.js" as="script"><link rel="prefetch" href="/assets/index.html-DFj_n8Se.js" as="script"><link rel="prefetch" href="/assets/index.html-BQZ2N4z7.js" as="script"><link rel="prefetch" href="/assets/index.html-D0i6md1h.js" as="script"><link rel="prefetch" href="/assets/index.html-BHBfWqHT.js" as="script"><link rel="prefetch" href="/assets/index.html-Dm7AZNYQ.js" as="script"><link rel="prefetch" href="/assets/index.html-CjuRj3cc.js" as="script"><link rel="prefetch" href="/assets/index.html-BsBwA6YM.js" as="script"><link rel="prefetch" href="/assets/index.html-B9NDVs__.js" as="script"><link rel="prefetch" href="/assets/index.html-O5Em1iia.js" as="script"><link rel="prefetch" href="/assets/index.html--R0sHhmu.js" as="script"><link rel="prefetch" href="/assets/index.html-BHQ5tlEL.js" as="script"><link rel="prefetch" href="/assets/index.html-DVq0BCiS.js" as="script"><link rel="prefetch" href="/assets/index.html-yNjNhZRd.js" as="script"><link rel="prefetch" href="/assets/index.html-DFYGfp5O.js" as="script"><link rel="prefetch" href="/assets/index.html-BWkpnahL.js" as="script"><link rel="prefetch" href="/assets/index.html-32lhUxYM.js" as="script"><link rel="prefetch" href="/assets/index.html-BMXGvRSm.js" as="script"><link rel="prefetch" href="/assets/index.html-DNRhQvN7.js" as="script"><link rel="prefetch" href="/assets/index.html-tvvkEjt9.js" as="script"><link rel="prefetch" href="/assets/index.html-Jlpvb1so.js" as="script"><link rel="prefetch" href="/assets/index.html-c6nioldI.js" as="script"><link rel="prefetch" href="/assets/index.html-BMQAowvG.js" as="script"><link rel="prefetch" href="/assets/index.html-ZdVfxVzB.js" as="script"><link rel="prefetch" href="/assets/index.html-Dv87A0F_.js" as="script"><link rel="prefetch" href="/assets/photoswipe.esm-DXWKOczD.js" as="script"><link rel="prefetch" href="/assets/index-B-M8YVCw.js" as="script"><link rel="prefetch" href="/assets/setupDevtools-QXEOFQJV-MLZ3j8OR.js" as="script">
  </head>
  <body>
    <div id="app"><!--[--><!--[--><!--[--><span tabindex="-1"></span><a href="#main-content" class="vp-skip-link sr-only">Skip to main content</a><!--]--><!--[--><div class="theme-container external-link-icon has-toc" vp-container><!--[--><header id="navbar" class="vp-navbar" vp-navbar><div class="vp-navbar-start"><button type="button" class="vp-toggle-sidebar-button" title="Toggle Sidebar"><span class="icon"></span></button><!--[--><a class="route-link vp-brand" href="/" aria-label="Take me home"><img class="vp-nav-logo" src="/flame.jpg" alt><!----><span class="vp-site-name hide-in-pad">Mes&#39;s Blog</span></a><!--]--></div><div class="vp-navbar-center"><!--[--><!----><!--]--></div><div class="vp-navbar-end"><!--[--><!----><!----><div class="vp-nav-item hide-in-mobile"><button type="button" class="vp-color-mode-switch" id="color-mode-switch"><svg xmlns="http://www.w3.org/2000/svg" class="icon auto-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="auto icon" name="auto" style="display:block;"><path d="M512 992C246.92 992 32 777.08 32 512S246.92 32 512 32s480 214.92 480 480-214.92 480-480 480zm0-840c-198.78 0-360 161.22-360 360 0 198.84 161.22 360 360 360s360-161.16 360-360c0-198.78-161.22-360-360-360zm0 660V212c165.72 0 300 134.34 300 300 0 165.72-134.28 300-300 300z"></path></svg><svg xmlns="http://www.w3.org/2000/svg" class="icon dark-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="dark icon" name="dark" style="display:none;"><path d="M524.8 938.667h-4.267a439.893 439.893 0 0 1-313.173-134.4 446.293 446.293 0 0 1-11.093-597.334A432.213 432.213 0 0 1 366.933 90.027a42.667 42.667 0 0 1 45.227 9.386 42.667 42.667 0 0 1 10.24 42.667 358.4 358.4 0 0 0 82.773 375.893 361.387 361.387 0 0 0 376.747 82.774 42.667 42.667 0 0 1 54.187 55.04 433.493 433.493 0 0 1-99.84 154.88 438.613 438.613 0 0 1-311.467 128z"></path></svg><svg xmlns="http://www.w3.org/2000/svg" class="icon light-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="light icon" name="light" style="display:none;"><path d="M952 552h-80a40 40 0 0 1 0-80h80a40 40 0 0 1 0 80zM801.88 280.08a41 41 0 0 1-57.96-57.96l57.96-58a41.04 41.04 0 0 1 58 58l-58 57.96zM512 752a240 240 0 1 1 0-480 240 240 0 0 1 0 480zm0-560a40 40 0 0 1-40-40V72a40 40 0 0 1 80 0v80a40 40 0 0 1-40 40zm-289.88 88.08-58-57.96a41.04 41.04 0 0 1 58-58l57.96 58a41 41 0 0 1-57.96 57.96zM192 512a40 40 0 0 1-40 40H72a40 40 0 0 1 0-80h80a40 40 0 0 1 40 40zm30.12 231.92a41 41 0 0 1 57.96 57.96l-57.96 58a41.04 41.04 0 0 1-58-58l58-57.96zM512 832a40 40 0 0 1 40 40v80a40 40 0 0 1-80 0v-80a40 40 0 0 1 40-40zm289.88-88.08 58 57.96a41.04 41.04 0 0 1-58 58l-57.96-58a41 41 0 0 1 57.96-57.96z"></path></svg></button></div><!--[--><div id="docsearch-container" style="display:none;"></div><div><button type="button" class="DocSearch DocSearch-Button" aria-label="Search"><span class="DocSearch-Button-Container"><svg width="20" height="20" class="DocSearch-Search-Icon" viewBox="0 0 20 20"><path d="M14.386 14.386l4.0877 4.0877-4.0877-4.0877c-2.9418 2.9419-7.7115 2.9419-10.6533 0-2.9419-2.9418-2.9419-7.7115 0-10.6533 2.9418-2.9419 7.7115-2.9419 10.6533 0 2.9419 2.9418 2.9419 7.7115 0 10.6533z" stroke="currentColor" fill="none" fill-rule="evenodd" stroke-linecap="round" stroke-linejoin="round"></path></svg><span class="DocSearch-Button-Placeholder">Search</span></span><span class="DocSearch-Button-Keys"><kbd class="DocSearch-Button-Key"><svg width="15" height="15" class="DocSearch-Control-Key-Icon"><path d="M4.505 4.496h2M5.505 5.496v5M8.216 4.496l.055 5.993M10 7.5c.333.333.5.667.5 1v2M12.326 4.5v5.996M8.384 4.496c1.674 0 2.116 0 2.116 1.5s-.442 1.5-2.116 1.5M3.205 9.303c-.09.448-.277 1.21-1.241 1.203C1 10.5.5 9.513.5 8V7c0-1.57.5-2.5 1.464-2.494.964.006 1.134.598 1.24 1.342M12.553 10.5h1.953" stroke-width="1.2" stroke="currentColor" fill="none" stroke-linecap="square"></path></svg></kbd><kbd class="DocSearch-Button-Key">K</kbd></span></button></div><!--]--><!--]--><button type="button" class="vp-toggle-navbar-button" aria-label="Toggle Navbar" aria-expanded="false" aria-controls="nav-screen"><span><span class="vp-top"></span><span class="vp-middle"></span><span class="vp-bottom"></span></span></button></div></header><!----><!--]--><!----><div class="toggle-sidebar-wrapper"><span class="arrow start"></span></div><aside id="sidebar" class="vp-sidebar" vp-sidebar><!----><ul class="vp-sidebar-links"><li><a class="route-link auto-link vp-sidebar-link" href="/" aria-label="Mes&#39;s Blog" iconsizing="both"><!--[--><iconify-icon class="vp-icon" icon="fa6-solid:house" width="1em" height="1em" sizing="both"></iconify-icon><!--]-->Mes&#39;s Blog<!----></a></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-header clickable" type="button"><!----><span class="vp-sidebar-title">雜項</span><span class="vp-arrow end"></span></button><!----></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-header clickable active" type="button"><!----><span class="vp-sidebar-title">Cpp-Miner</span><span class="vp-arrow down"></span></button><ul class="vp-sidebar-links"><li><section class="vp-sidebar-group"><button class="vp-sidebar-header clickable" type="button"><!----><span class="vp-sidebar-title">Miner 新手教學</span><span class="vp-arrow end"></span></button><!----></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-header clickable active" type="button"><!----><span class="vp-sidebar-title">Miner 本篇</span><span class="vp-arrow down"></span></button><ul class="vp-sidebar-links"><li><a class="route-link auto-link vp-sidebar-link" href="/Cpp-Miner/Miner_main/" aria-label="礦坑系列 ── C++03 ~ C++17 主要變化介紹" iconsizing="both"><!---->礦坑系列 ── C++03 ~ C++17 主要變化介紹<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/Cpp-Miner/Miner_main/Value_Categories/" aria-label="礦坑系列 ── 值類別 Value Categoraries" iconsizing="both"><!---->礦坑系列 ── 值類別 Value Categoraries<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/Cpp-Miner/Miner_main/malloc_new_POD/" aria-label="礦坑系列 ── malloc、new 與 POD Type" iconsizing="both"><!---->礦坑系列 ── malloc、new 與 POD Type<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/Cpp-Miner/Miner_main/Std_Function/" aria-label="礦坑系列 ── std::function" iconsizing="both"><!---->礦坑系列 ── std::function<!----></a></li><li><a class="route-link route-link-active auto-link vp-sidebar-link active" href="/Cpp-Miner/Miner_main/Structured_Binding/" aria-label="礦坑系列 ── 結構化綁定 Structured Binding Declaration" iconsizing="both"><!---->礦坑系列 ── 結構化綁定 Structured Binding Declaration<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/Cpp-Miner/Miner_main/Concept_SFINAE_DetectionIdiom/" aria-label="礦坑系列 ── Concept と SFINAE と Detection Idiom" iconsizing="both"><!---->礦坑系列 ── Concept と SFINAE と Detection Idiom<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/Cpp-Miner/Miner_main/Dependent_Name/" aria-label="(WIP) 礦坑系列 ── Dependent Name 與 Name lookup" iconsizing="both"><!---->(WIP) 礦坑系列 ── Dependent Name 與 Name lookup<!----></a></li></ul></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-header clickable" type="button"><!----><span class="vp-sidebar-title">Miner 黑魔法</span><span class="vp-arrow end"></span></button><!----></section></li></ul></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-header clickable" type="button"><!----><span class="vp-sidebar-title">risc-v</span><span class="vp-arrow end"></span></button><!----></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-header clickable" type="button"><!----><span class="vp-sidebar-title">Linux</span><span class="vp-arrow end"></span></button><!----></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-header clickable" type="button"><!----><span class="vp-sidebar-title">數值線代</span><span class="vp-arrow end"></span></button><!----></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-header clickable" type="button"><!----><span class="vp-sidebar-title">雜記</span><span class="vp-arrow end"></span></button><!----></section></li></ul><!----></aside><!--[--><main id="main-content" class="vp-page"><!--[--><!----><!----><nav class="vp-breadcrumb disable"></nav><div class="vp-page-title"><h1><!---->礦坑系列 ── 結構化綁定 Structured Binding Declaration</h1><!----><hr></div><!----><!----><div class="theme-hope-content" vp-content><h1><!----></h1><p>礦坑系列首頁：<strong><a href="https://github.com/Mes0903/Cpp-Miner/tree/hackmd" class="redlink">首頁</a></strong></p><p>hackmd 版首頁：<strong><a href="https://hackmd.io/@Mes/Cpp_Miner/https%3A%2F%2Fhackmd.io%2F%40Mes%2FPreface" class="redlink">首頁</a></strong></p><h1 id="" tabindex="-1"><a class="header-anchor" href="#"><span></span></a></h1><h2 id="前言" tabindex="-1"><a class="header-anchor" href="#前言"><span><span class="orange">前言</span></span></a></h2><p>Structured binding declaration 是 C++17 加入的一個新特性，它讓我們能夠更簡單地去處理多個回傳值或多變數的情況，通常會在要接 tuple_like 的容器或 Struct 回傳值時搭配 auto 來使用</p><p>我盡量將原裡理解並寫在了「介紹及原理」的部分，有些部分是翻譯了官方的文件，原先只是想弄個翻譯，結果翻著翻著發現官方有些地方講的不是讓人很明白，於是就又加上了自己的文字，漸漸地就變一篇文件了，如果只想知道如何使用的朋友可以直接跳到下方的應用部分</p><h2 id="語法" tabindex="-1"><a class="header-anchor" href="#語法"><span><span class="orange">語法</span></span></a></h2><p>主要有三種初始化的方式：</p><blockquote><p><strong>1. attr(opt) cv(opt) auto ref-qualifier(opt) [idendentifier-list] = expression;</strong><br><strong>2. attr(opt) cv(opt) auto ref-qualifier(opt) [idendentifier-list]{ expression };</strong> <br><strong>3. attr(opt) cv(opt) auto ref-qualifier(opt) [idendentifier-list]( expression );</strong></p></blockquote><blockquote><p>opt 代表的是 optional，可加可不加的意思</p></blockquote><ul><li><p><strong>attr</strong> 🐳<br> 指的是 <a href="https://en.cppreference.com/w/cpp/language/attributes" target="_blank" rel="noopener noreferrer">attrubutes</a>，可加可不加</p></li><li><p><strong>cv</strong> 🐳<br> 可能是<a href="https://en.cppreference.com/w/cpp/language/cv" target="_blank" rel="noopener noreferrer">cv-qualifier</a>，後方需加上 auto，需要的話也可以加上 static、thread_local 之類的<a href="https://en.cppreference.com/w/cpp/language/storage_duration" target="_blank" rel="noopener noreferrer">儲存類說明符</a>，但不推薦使用到 volatile</p></li><li><p><strong>ref-qualifier</strong> 🐳<br><code>&amp;</code> 或 <code>&amp;&amp;</code>，可加可不加，取決於你的需求</p></li><li><p><strong>identifier-list</strong> 🐳<br> 這裡放妳要使用的變數名稱，他實際上不是變數而是標示符，它們之間需要以逗點 <code>,</code> 隔開，後方會有例子</p></li><li><p><strong>expression</strong> 🐳<br> 表達式，通常會放 array、tuple-like 容器或是個沒有 union 成員的 Class，語法上會是 assignment-expression，它們不能是 <code>throw</code> 表達式，並且在 top-level 不能有逗號運算符，這裡應該是指 expression 能夠有 sub-expression，而它要的是最上層的那個 (感謝marty大佬)。 另外，expression 內的變數名不能和 identifier-list 內的變數名相同，簡單來說就是不能重複宣告同樣名字的變數</p></li></ul><h2 id="介紹及原理" tabindex="-1"><a class="header-anchor" href="#介紹及原理"><span><span class="orange">介紹及原理</span></span></a></h2><p>Structed binding 會在你現在的 <a href="https://en.cppreference.com/w/cpp/language/scope" target="_blank" rel="noopener noreferrer">scope</a> 內採用你 identifier-list 裡給的標示符，並且將其連結到你 expression 裡寫的元素或子物件。採用時它會先創造出一個特殊的變數來存取你的初始化敘述(initializer)，型態取決於你的 expression，這個變數的名稱這裡我們先取作 <code>__e</code> ，由於 <code>__e</code> 可能是個容器或參考，所以我們給他取叫 initializer，沒看過這個詞的朋友不用太擔心，而 <code>__e</code> 在存取時有一些規則：</p><ul><li><p><strong>如果 expression 是個 A型態的 array，而且你沒有使用 ref-qualifier，那麼 <code>__e</code> 會是原先 expression 計算結果的複本，型態會是 <code>cv A</code>，cv指的就是<a href="https://en.cppreference.com/w/cpp/language/cv" target="_blank" rel="noopener noreferrer">cv-qualifier</a>。而 <code>__e</code> 內的元素會依據你使用的初始化方式(最上方寫的三種方式)來初始化。</strong></p><p>如果你使用的是第一種(<code>=</code>號)方式，那麼 <code>__e</code> 內的元素會使用<a href="https://en.cppreference.com/w/cpp/language/copy_initialization" target="_blank" rel="noopener noreferrer">複製初始化</a>來初始化為你 expression 內相對應的元素；</p><p>若你使用的是第二或第三種方法，那麼 <code>__e</code> 內的元素會使用<a href="https://en.cppreference.com/w/cpp/language/direct_initialization" target="_blank" rel="noopener noreferrer">直接初始化</a>來初始化為你 expression 內相對應的元素</p></li><li><p><strong>如果不是上面的那種情況，那麼編譯器先將 Structured Binding 改寫，直接使用 <code>__e</code> 這個名稱作為原先 expression 的複本，像這樣：</strong></p><blockquote><p><strong>1. attr(opt) cv(opt) auto ref-qualifier(opt) __e = expression;</strong><br><strong>2. attr(opt) cv(opt) auto ref-qualifier(opt) __e{ expression };</strong><br><strong>3. attr(opt) cv(opt) auto ref-qualifier(opt) __e( expression );</strong></p></blockquote><p><code>__e</code> 會是個匿名的 tuple-like 的容器(沒ref-qualifier時) 或是 tuple-like 的容器的參考(有ref-qualifier時)，簡短來說妳有寫 <code>&amp;</code> 這個 <code>__e</code> 就會是個參考，如果沒寫就是個容器。 接著編譯器會去看它是否符合 <a href="https://timsong-cpp.github.io/cppwp/n4861/dcl.struct.bind#4" target="_blank" rel="noopener noreferrer">Tuple-Like&quot; Binding Protoco ( tuple-like 連結協定)</a>，簡單來說會長這樣：</p><ul><li><code>std::tuple_size&lt;__E&gt;::value</code> 必須是個格式正確的整數常量表達式 (integer constant expression)</li><li>identifier-list 內元素的數量必須與 <code>std::tuple_size&lt;__E&gt;::value</code> 相同</li><li>如果上面兩項有其中一項不符合，便去檢查這個 Class 的成員變數是否都為 public，如果不是(有 private 的成員變數)，則編譯錯誤</li></ul><p>接著 identifier-list 內的元素便會「連結」到 <code>__e</code> 內相對應的元素，這也是妳有寫 <code>&amp;</code> 時，對 identifier-list 內的元素做改動就能改動到原容器的原因，因為 <code>__e</code> 是個參考，舉個例子：</p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" data-title="cpp" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">std::tuple</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">&lt;int</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">int&gt;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> a{</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">2</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">auto</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> [x,y] </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">=</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> a;</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> // __e 是個容器， x 與 std::get&lt;0&gt;(__e) 連結， y 與 std::get&lt;1&gt;(__e) 連結</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">auto</span><span style="--shiki-light:#A626A4;--shiki-dark:#56B6C2;"> &amp;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">[x,y] </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">=</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> a;</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> // __e 是 a 的左值參考，  x 與 std::get&lt;0&gt;(__e) 連結， y 與 std::get&lt;1&gt;(__e) 連結</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">auto</span><span style="--shiki-light:#A626A4;--shiki-dark:#56B6C2;"> &amp;&amp;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">[x, y] </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">=</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> std::</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">make_tuple</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">( </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">2</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> );</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> // __e 是右邊那個 tuple 的右值參考，x 與 std::get&lt;0&gt;(__e) 連結， y 與 std::get&lt;1&gt;(__e) 連結</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Code 有點長，大家可以複製下來看，在網頁上可能不太好閱讀。 可以看見內部是使用 <code>std::get&lt;&gt;()</code> 來存取元素的，因此妳的 expression 必須是個回傳 tuple-like 容器的敘述，否則妳的 <code>__e</code> 不會是個 tuple-like 的容器(或容器的參考)，那個也就無法使用 <code>std::get&lt;&gt;()</code> 了</p><div class="hint-container info"><p class="hint-container-title">Info</p><p>💡 這邊只舉了 tuple-like 容器的例子，因為原生陣列沒有複製建構子，也就是說他不能被改寫成上面那三種樣式，也就不能用那三種方法初始化，可以看下面這個例子，它會噴錯：</p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" data-title="cpp" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">int</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> a</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">[</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">2</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">]{ </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">2</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> };</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">int</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> b</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">[</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">2</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">] </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">=</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> a;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>所以會需要另外規定方式來初始化。</p></div><p>「連結」這個動作無法以 C++ 語言描述，妳可以把他想像成參考，又或是宏定義，但要記得他不是，他是 C++ 語言的本身，沒辦法用 C++ 寫出來，已經類似語言特性的概念了，就好像我們無法自己實作 function-body 的大括號一樣 (感謝Cy解釋)</p><div class="hint-container caution"><p class="hint-container-title">Caution</p><p>💡 官方文件是這麼寫的： Structured Binding 像是個參考，它是某個已經存在的物件的別名，但 Structured Binding 不是參考，它不需要是個引用類型。</p></div><p><s>挺玄學的</s>，我自己是用「類似宏定義」來理解的，底下也會如此解釋，但各位要記得它不是宏定義，也許是為了確保將標示符丟進 <code>std::remove_reference_t&lt;decltype((標示符))&gt;()</code> 時型態要與連結到的元素丟進 <code>std::remove_reference_t&lt;decltype((連結到的元素))&gt;()</code> 一樣才如此設計的</p></li></ul><p>接下來我會詳細的講解一下內部的原理，這裡用 <code>__E</code> 來表示 <code>__e</code> 的型態，也就是說 <code>__E</code> 為初始化敘述(initializer) 的型態，另外我們也可以說 <code>__E</code> 與 <code>std::remove_reference_t&lt;decltype((__e))&gt;</code> 等價</p><p>上述的初始化結束後，它會根據 <code>__E</code> 的狀況來進行連結，會有三種情況：</p><ul><li><p><strong>如果 <code>__E</code> 是個 array 型態 ，那麼 identifier-list 內的元素會與初始化敘述(initializer) 內相對應的元素連結</strong></p><p>這種情況下，每個 identifier-list 內的標示符會是一個左值(lvalue)，與初始化敘述(initializer) 內相應的元素連結，也因此，identifier-list 內的標示符數量需要與 array 內的變數數量一樣多，看一下下面這個例子：</p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" data-title="cpp" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">int</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> a</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">[</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">2</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">] </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">=</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">2</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">};</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">auto</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> [x,y] </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">=</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> a;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p><code>auto [x,y] = a;</code> 會創建一個名字叫 <code>__e</code> 的 array <code>__e[2]</code>，利用<a href="https://en.cppreference.com/w/cpp/language/copy_initialization" target="_blank" rel="noopener noreferrer">複製初始化</a>來初始化 <code>__e[2]</code>，之後 x 與 y 分別會與 <code>__e[0]</code> 與 <code>__e[1]</code> 連結，你可以把他們想像成參考，或是宏定義，但要記住它們實際上不是</p><p>如果有寫 ref-qualifier 且 expression 回傳的是 lvalue，則 identifier-list 內的元素會間接與 a 內的元素連結，對 identifier-list 內的元素的操作將會反應到 a 的元素上：</p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" data-title="cpp" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">int</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> a</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">[</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">2</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">] </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">=</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">2</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">};</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">auto</span><span style="--shiki-light:#A626A4;--shiki-dark:#56B6C2;">&amp;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> [x,y] </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">=</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> a;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p><code>auto&amp; [x,y] = a;</code> 會創建一個名字叫 <code>__e</code> 的參考引用 expression 的計算結果，而 identifier-list 內的元素則會透過 <code>__e</code> 間接變為 a 內元素的參考，可以把他想像成這樣：</p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" data-title="cpp" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">int</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> a</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">[</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">2</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">] </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">=</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">2</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">};</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">auto</span><span style="--shiki-light:#A626A4;--shiki-dark:#56B6C2;"> &amp;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> __e </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">=</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> a;</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    // 等價於 int(&amp;e)[2] = a;</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">#define</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> x</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> __e</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">[</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">0</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">]</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">#define</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> y</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> __e</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">[</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">]</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>而如果 expression 回傳的是 rvalue，則 identifier-list 內的元素會與 <code>__e</code> 內的元素連結：</p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" data-title="cpp" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">using</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> T</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> =</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> int</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">[</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">3</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">];</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">auto</span><span style="--shiki-light:#A626A4;--shiki-dark:#56B6C2;"> &amp;&amp;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">[x, y, z] </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">=</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> T{ </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">2</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">3</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> };</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>可以把他想像成這樣：</p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" data-title="cpp" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">auto</span><span style="--shiki-light:#A626A4;--shiki-dark:#56B6C2;"> &amp;&amp;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">__e </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">=</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> T{ </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">2</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">3</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> };</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">#define</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> x</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> __e</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">[</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">0</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">]</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">#define</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> y</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> __e</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">[</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">]</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">#define</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> z</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> __e</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">[</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">2</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">]</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>當然上面這兩個例子都是偽代碼，內部當然不是這樣的，連結無法以 C++ 語言來描述，x 與 y 僅僅是標示符，所以不會是上面這個樣子，這只是個示意</p></li><li><p><strong>如果 <code>__E</code> 是個沒有 union 成員的 Class 型態，而且 <a href="https://en.cppreference.com/w/cpp/utility/tuple/tuple_size" target="_blank" rel="noopener noreferrer">std::tuple_size&lt;__E&gt;</a> 是個有成員的完全型(不用管這個成員的型態或可訪問性如何)，簡單來說就是 <code>__e</code> 能夠做成 tuple-like 的容器，符合 tuple-like 連結協定，那麼就會使用 tuple-like 連結協定來進行連結</strong></p><p>與前面提到的一樣，首先 <code>std::tuple_size&lt;__E&gt;::value</code> 必須是個格式正確的整數常量表達式 (integer constant expression)，並且 identifier-list 內元素的數量必須與 <code>std::tuple_size&lt;__E&gt;::value</code> 相同</p><p>再來對於每個標示符，都會連結一個元素(也就是 <code>__e</code> 內的元素)，元素的型態會類似是 「<code>std::tuple_element&lt;i,__E&gt;::type</code> 的 &quot;引用&quot;」，注意它是「引用」，<code>i</code> 指的是 <code>__e</code> 內第 i 個元素，如果這個型態對應的初始化敘述(initializer) 是左值，那這個變數就會是左值引用，如果是右值那就是右值引用</p><p>連結到的第 i 個元素詳細如下：</p><ul><li><p>如果通過 <a href="https://en.cppreference.com/w/cpp/language/operator_member_access" target="_blank" rel="noopener noreferrer">Class成員訪問</a>的方式在 <code>__E</code> 的範圍內查找到至少一個函式模板，且這個函式模板的第一個模板參數是個 <a href="https://www.learncpp.com/cpp-tutorial/template-non-type-parameters/" target="_blank" rel="noopener noreferrer">non-type參數</a>，那麼第 i 個元素的初始化敘述(initializer) 會是 <code>e.get&lt;i&gt;()</code></p></li><li><p>如果沒有找到符合情況的函式模板，那麼會使用 <a href="https://en.cppreference.com/w/cpp/language/adl" target="_blank" rel="noopener noreferrer">argument-dependent lookup</a> 的方式來呼叫 <code>get&lt;i&gt;(__e)</code>，因此第 i 個元素的初始化敘述(initializer) 會是 <code>e.get&lt;i&gt;(__e)</code></p></li></ul><p>在這些初始化敘述中，如果 <code>__e</code> 是一個左值參考 (這只會發生在你的 <code>ref-qualifier</code> 是 <code>&amp;</code> ，或是你的初始化敘述是個左值而且 <code>ref-qualifier</code> 是 <code>&amp;&amp;</code> ，簡單來說就是收合為 <code>&amp;</code> 時)，那麼你將 expression 內相對應的元素會是一個左值 (這聽起來很廢話，但重點在下一句)</p><p>否則 expression 內相對應的元素會是一個消亡值(xvalue)，因為內部實際上執行了一次完美轉發(perfect-forwarding)， 而 <code>i</code> 會是個型態為 <code>std::size_t</code> 的純右值(prvalue)，因此 <code>&lt;i&gt;</code> 會被轉換(解釋)為<a href="https://en.cppreference.com/w/cpp/language/template_parameters" target="_blank" rel="noopener noreferrer">模板參數列表</a></p><div class="hint-container info"><p class="hint-container-title">Info</p><p>💡 有三點提醒大家一下</p><ul><li>identifier-list 內的標示符、<code>__e</code> 內的元素與 expression 內相對應的元素，這三個會有一樣的生命週期</li><li>我們通常會直接稱 identifier-list 內的標示符為「變數」，儘管它不是，但它使用上與變數基本上一樣，概念也類似</li><li>identifier-list 內第i個元素型態會是 <code>std::tuple_element&lt;i,E&gt;::type</code></li></ul></div><p>看一下這個例子：</p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" data-title="cpp" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">float</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> x{};</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">  char</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> y{};</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">  int</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> z{};</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">  std::</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">tuple</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&lt;</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">float</span><span style="--shiki-light:#A626A4;--shiki-dark:#56B6C2;"> &amp;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">char</span><span style="--shiki-light:#A626A4;--shiki-dark:#56B6C2;"> &amp;&amp;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">int</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&gt; </span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">tpl</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">( </span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">x</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;">std</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">::</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">move</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">( y ), </span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">z</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> );</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">  const</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> auto</span><span style="--shiki-light:#A626A4;--shiki-dark:#56B6C2;"> &amp;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">[a, b, c] </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">=</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> tpl;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>a 的名字叫做「Structured Binding」，連結到 tpl內第一個元素， <code>decltype(a)</code> 為 <code>float&amp;</code><br> b 的名字叫做「Structured Binding」，連結到 tpl內第二個元素， <code>decltype(b)</code> 為 <code>char&amp;&amp;</code><br> c 的名字叫做「Structured Binding」，連結到 tpl內第三個元素， <code>decltype(c)</code> 為 <code>const int</code></p></li><li><p><strong>如果不是以上兩種情況，則 expression 內的每個 non-static 成員變數都需要是個直接成員或是 expression 的相同基類，而且 Structured Binding 格式需要正確，讓我們能夠間接使用 <code>__e.name</code> 來呼叫變數。你的 expression 內不能有匿名或是 union 的成員，identifier-list 內的標示符數量需要與 non-static 的成員變數數量相同。</strong></p><p>每個 identifier-list 內的標示符都會連結到相對應的成員變數，實際上是連結到 <code>__e.m_i</code> ，<code>m_i</code> 表示第 i 個成員變數，另外 Structured Binding 支援 bit field 用法，看這個例子：</p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" data-title="cpp" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">#include</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &lt;iostream&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">struct</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> S</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    mutable</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> int</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> x1 : </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">2</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    volatile</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> double</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> y1;</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    int</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> z1;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">};</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">int</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> main</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">() {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    using</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> f</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> =</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> S</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;    </span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    const</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> auto</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> [x, y, z] </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">=</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> f</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">();</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    return</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 0</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>x 會是個整數左值標示符，連結到一個 2-bit 的整數元素 x1，y 會連結到 const volatile double 的元素 y1</p></li></ul><h2 id="使用-structured-binding" tabindex="-1"><a class="header-anchor" href="#使用-structured-binding"><span><span class="orange">使用 Structured Binding</span></span></a></h2><blockquote><p>記得要切換成 C++17 才能夠使用</p></blockquote><p>現在我們舉個簡單的例子(<a href="https://www.youtube.com/watch?v=eUsTO5BO3WI&amp;ab_channel=TheCherno" target="_blank" rel="noopener noreferrer">來源</a>)，現在我要定義一個「人」的函式，人會有年齡、名字等等，因此它的回傳型態會是一個 <code>std::tuple&lt;std::string, int&gt;</code>：</p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" data-title="cpp" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">std::</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">tuple</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&lt;std::</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">string</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">int</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&gt; </span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">CreatePerson</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">() {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    return</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> { </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;Cherno&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">24</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> };</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>而在 <code>main</code> 內我們需要用到資料時，過去需要像這樣：</p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" data-title="cpp" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">std::tuple</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">&lt;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">std::string, </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">int&gt;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> person </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">=</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> CreatePerson</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">();</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    // 當然你可以用auto</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">std::string </span><span style="--shiki-light:#A626A4;--shiki-dark:#56B6C2;">&amp;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">name </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">=</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> std::</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">get</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&lt;</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">0</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&gt;( person );</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">int</span><span style="--shiki-light:#A626A4;--shiki-dark:#56B6C2;"> &amp;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">age </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">=</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> std::</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">get</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&lt;</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&gt;( person );</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>而對 tuple 熟悉的朋友可能會使用 <code>std::tie</code>：</p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" data-title="cpp" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">std::string name;</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">int</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> age;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;">std</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">::</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">tie</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">( name, age ) </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">=</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> CreatePerson</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">();</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>好多了，我們不需要為了賦值多個變數而額外創個 <code>person</code>，但它仍然需要 3 行，又或許我們可以使用 Struct，但在 C++17 後多了一個新特性 Structured Binding，現在我們只需要這樣：</p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" data-title="cpp" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">auto</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> [name, age] </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">=</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> CreatePerson</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">();</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>而它也不只限定 tuple-like 的容器，也可以與 Struct 和原生陣列連結，看一下這個例子(<a href="https://ithelp.ithome.com.tw/articles/10217358" target="_blank" rel="noopener noreferrer">來源</a>)：</p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" data-title="cpp" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">struct</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> TeaShopOwner</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    int</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> id;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    std::string name;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">};</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">auto</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> GetTeaShopOwner</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">() -&gt; </span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">TeaShopOwner</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    TeaShopOwner owner { </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;test&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}; </span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    return</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> owner;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">auto</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> [id, name] </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">=</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> GetTeaShopOwner</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">();</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">   //  id = 1 ， name = &quot;test&quot;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如此一來 id 便會等於 1，name 則會是 &quot;test&quot; 了。Structured Binding 的另一個好處是可以搭配 Ranged-based for Loop 使用：</p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" data-title="cpp" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">struct</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> TeaShopOwner</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    int</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">         id;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    std::string name;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">};</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">std::vector</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">&lt;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">TeaShopOwner</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">&gt;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> owners {{1, &quot;COCO&quot;}, {2, &quot;1Shit&quot;}};</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// C++17 前的用法</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">for</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> (</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">const</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> auto</span><span style="--shiki-light:#A626A4;--shiki-dark:#56B6C2;">&amp;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> owner : owners) {</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">    printf</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;Owner id = </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">%d</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;">\n</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">owner</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">id</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// Using Structured Binding</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">for</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> (</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">const</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> auto</span><span style="--shiki-light:#A626A4;--shiki-dark:#56B6C2;">&amp;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> [id, _] : owners) {</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">    printf</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;Owner id = </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">%d</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;">\n</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, id);</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>留意上面的 Ranged-based for-loop 接住 <code>owners</code> 時，將第二個變數名稱取為 <code>_</code>，通常會利用這個手法來表示 <code>name</code> 在迴圈裡不受「重視」</p><p>以往 C++ 函數的回傳值多是單一型別，如 bool, int。有了 Structured Binding 再搭配其他技巧，在處理回傳值時更有彈性</p><h2 id="補充" tabindex="-1"><a class="header-anchor" href="#補充"><span><span class="orange">補充</span></span></a></h2><ul><li><p>對成員的 <code>get</code> 進行查找時會忽略可訪問性與非類型模板參數的確切類型。像是 <code>template&lt;char*&gt; void get();</code> ，成員將導致使用成員解釋，即使格式是錯的</p></li><li><p>有些 <code>[</code> 前方的聲明僅適用於隱藏變數 <code>__e</code> ，而不適用 identifier-list 內的元素：</p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" data-title="cpp" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">#include</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &lt;cassert&gt;</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">#include</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &lt;tuple&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">int</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> main</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">() {</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">  int</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> a </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">=</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, b </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">=</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 2</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">  const</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> auto</span><span style="--shiki-light:#A626A4;--shiki-dark:#56B6C2;"> &amp;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">[x, y] </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">=</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> std::</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">tie</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">( a, b );</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    // x and y are of type int&amp;</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">  auto</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> [z, w] </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">=</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> std::</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">tie</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">( a, b );</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    // z and w are still of type int&amp;</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">  assert</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">( </span><span style="--shiki-light:#A626A4;--shiki-dark:#56B6C2;">&amp;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">z </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">==</span><span style="--shiki-light:#A626A4;--shiki-dark:#56B6C2;"> &amp;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">a );</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    // passes</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">  return</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 0</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>tuple-like 的意思是使用 <code>std::tuple_size&lt;&gt;</code> 會是個完全型，即使它可能導致格式錯誤：</p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" data-title="cpp" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">#include</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &lt;iostream&gt;</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">#include</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &lt;tuple&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">struct</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> A</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    int</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> x;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">};</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">namespace</span><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;"> std</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">template</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> &lt;&gt;</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">struct</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> tuple_size</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&lt;::</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">A</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&gt; {};</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    // namespace std</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">int</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> main</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">() {</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    auto</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> [x] </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">=</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> A{};</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    // error; the &quot;data member&quot; interpretation is not considered.</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    return</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 0</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ul><h2 id="參考資料" tabindex="-1"><a class="header-anchor" href="#參考資料"><span><span class="orange">參考資料</span></span></a></h2><p><strong><a href="https://en.cppreference.com/w/cpp/language/structured_binding" class="redlink">1. Structured binding declaration (since C++17)</a></strong> (文章部分來源，例子來源)</p><p><strong><a href="https://codertw.com/%E7%A8%8B%E5%BC%8F%E8%AA%9E%E8%A8%80/449584/" class="redlink">2. C 17嚐鮮：結構化繫結宣告（Structured Binding Declaration）<br></a></strong></p><p><strong><a href="https://zh-blog.logan.tw/2019/10/29/cxx-17-structured-binding/" class="redlink">3. C++ 17 結構化綁定</a></strong></p><p><strong><a href="https://blog.csdn.net/LYR1994/article/details/105340773?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=Structured%20binding%20declaration&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-4-105340773.first_rank_v2_pc_rank_v29" class="redlink">4. C++ 学习指南基础（三）</a></strong></p><p><strong><a href="https://blog.csdn.net/zwvista/article/details/78111346?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522161728731916780264014555%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=161728731916780264014555&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-2-78111346.first_rank_v2_pc_rank_v29&amp;utm_term=Structured+binding+declaration&amp;spm=1018.2226.3001.4187" class="redlink">5. C++17尝鲜：结构化绑定声明（Structured Binding Declaration）</a></strong></p><p><strong><a href="https://blog.csdn.net/yangsenuestc/article/details/79840670?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522161728731916780264014555%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=161728731916780264014555&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-79840670.first_rank_v2_pc_rank_v29&amp;utm_term=Structured+binding+declaration" class="redlink">6. C++17新特性(1) -- 结构化绑定初始化(Structured binding declaration)</a></strong></p><p><strong><a href="https://stackoverflow.com/questions/44963201/when-does-an-incomplete-type-error-occur-in-c" class="redlink">7. When does an Incomplete Type error occur in C++</a></strong></p><p><strong><a href="https://en.cppreference.com/w/cpp/types/remove_reference" class="redlink">8. std::remove_reference</a></strong></p><p><strong><a href="https://www.mdeditor.tw/pl/pjYZ/zh-tw" class="redlink">9. remove_reference 引用移除工作原理</a></strong></p><p><strong><a href="https://en.cppreference.com/w/cpp/types/is_same" class="redlink">10. std::is_same</a></strong></p><p><strong><a href="https://en.cppreference.com/w/cpp/language/storage_duration" class="redlink">11. Storage class specifiers</a></strong></p><p><strong><a href="https://www.youtube.com/watch?v=eUsTO5BO3WI&amp;ab_channel=TheCherno" class="redlink">12. STRUCTURED BINDINGS in C++ </a></strong> (例子來源)</p><p><strong><a href="https://stackoverflow.com/questions/53787312/if-with-initializer-in-structured-binding-declaration-example-ill-formed" class="redlink">13. if-with-initializer in structured binding declaration example ill formed?</a></strong></p><p><strong><a href="https://blog.csdn.net/zqxf123456789/article/details/71582384" class="redlink">14. [C++] - 中的复制初始化(copy initialization)</a></strong></p><p><strong><a href="https://en.cppreference.com/w/cpp/language/attributes" class="redlink">15. Attribute specifier sequence(since C++11)</a></strong></p><p><strong><a href="https://en.cppreference.com/w/cpp/language/cv" class="redlink">16. cv (const and volatile) type qualifiers</a></strong></p><p><strong><a href="https://en.cppreference.com/w/cpp/language/copy_initialization" class="redlink">17. Copy initialization</a></strong></p><p><strong><a href="https://stackoverflow.com/questions/1051379/is-there-a-difference-between-copy-initialization-and-direct-initialization" class="redlink">18. Is there a difference between copy initialization and direct initialization?</a></strong></p><p><strong><a href="https://docs.microsoft.com/zh-tw/cpp/cpp/initializers?view=msvc-160" class="redlink">19. Initializers</a></strong></p><p><strong><a href="https://stackoverflow.com/questions/22577679/what-is-a-sub-expression-in-c/22577708" class="redlink">20. What is a sub-expression in C?</a></strong></p><p><strong><a href="https://en.cppreference.com/w/cpp/utility/tuple/tuple_size" class="redlink">21. std<iconify-icon class="vp-icon" icon="fa6-solid:tuple_size\&lt;std" height="1em" sizing="height"></iconify-icon>tuple&gt;</a></strong></p><p><strong><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/p0144r0.pdf" class="redlink">22. P0144R0</a></strong></p><p><strong><a href="https://stackoverflow.com/questions/39763517/structured-bindings-implementation-underground-and-stdtuple" class="redlink">23. Structured bindings implementation underground and std::tuple</a></strong></p><p><strong><a href="https://en.cppreference.com/w/cpp/language/operator_member_access" class="redlink"></a></strong></p><p><strong><a href="" class="redlink">24. Member access operators</a></strong></p><p><strong><a href="https://www.learncpp.com/cpp-tutorial/template-non-type-parameters/" class="redlink">25. Template non-type parameters</a></strong></p><p><strong><a href="https://en.cppreference.com/w/cpp/language/adl" class="redlink">26. Argument-dependent lookup</a></strong></p><p><strong><a href="https://en.cppreference.com/w/cpp/language/template_parameters" class="redlink"></a></strong></p><p><strong><a href="" class="redlink">27. Template parameters and template arguments<br></a></strong></p><p><strong><a href="https://en.cppreference.com/w/cpp/utility/tuple/get" class="redlink">28. std<iconify-icon class="vp-icon" icon="fa6-solid:get(std" height="1em" sizing="height"></iconify-icon>tuple)</a></strong></p><p><strong><a href="http://eel.is/c++draft/dcl.struct.bind#4" class="redlink">29. Structured binding declarations [dcl.struct.bind]</a></strong></p><p><strong><a href="https://stackoverflow.com/questions/49795131/understand-structured-binding-in-c17-by-analogy" class="redlink">30. Understand structured binding in C++17 by analogy</a></strong></p><p><strong><a href="https://stackoverflow.com/questions/55329651/structured-binding-on-const" class="redlink">31. Structured binding on const</a></strong></p><p><strong><a href="https://stackoverflow.com/questions/45821678/is-always-the-address-of-a-reference-equal-to-the-address-of-origin" class="redlink">32. Is always the address of a reference equal to the address of origin?</a></strong></p><p><strong><a href="https://stackoverflow.com/questions/17259531/c-primary-expressions-is-it-primary-expression-or-not" class="redlink">33. C++ primary expressions - Is it primary expression or not?</a></strong></p><p><strong><a href="https://ithelp.ithome.com.tw/articles/10217358" class="redlink">34. DAY 16：Structured Bindings</a></strong> (例子來源)</p></div><!----><footer class="vp-page-meta"><div class="vp-meta-item edit-link"><a class="auto-link external-link vp-meta-label" href="https://github.com/Mes0903/Mes0903.github.io/edit/main/src/Cpp-Miner/Miner_main/Structured_Binding/README.md" aria-label="Edit this page" rel="noopener noreferrer" target="_blank" iconsizing="both"><!--[--><svg xmlns="http://www.w3.org/2000/svg" class="icon edit-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="edit icon" name="edit"><path d="M430.818 653.65a60.46 60.46 0 0 1-50.96-93.281l71.69-114.012 7.773-10.365L816.038 80.138A60.46 60.46 0 0 1 859.225 62a60.46 60.46 0 0 1 43.186 18.138l43.186 43.186a60.46 60.46 0 0 1 0 86.373L588.879 565.55l-8.637 8.637-117.466 68.234a60.46 60.46 0 0 1-31.958 11.229z"></path><path d="M728.802 962H252.891A190.883 190.883 0 0 1 62.008 771.98V296.934a190.883 190.883 0 0 1 190.883-192.61h267.754a60.46 60.46 0 0 1 0 120.92H252.891a69.962 69.962 0 0 0-69.098 69.099V771.98a69.962 69.962 0 0 0 69.098 69.098h475.911A69.962 69.962 0 0 0 797.9 771.98V503.363a60.46 60.46 0 1 1 120.922 0V771.98A190.883 190.883 0 0 1 728.802 962z"></path></svg><!--]-->Edit this page<!----></a></div><div class="vp-meta-item git-info"><!----><!----></div></footer><nav class="vp-page-nav"><a class="route-link auto-link prev" href="/Cpp-Miner/Miner_main/Std_Function/" aria-label="礦坑系列 ── std::function" iconsizing="both"><div class="hint"><span class="arrow start"></span>Prev</div><div class="link"><!---->礦坑系列 ── std::function</div></a><a class="route-link auto-link next" href="/Cpp-Miner/Miner_main/Concept_SFINAE_DetectionIdiom/" aria-label="礦坑系列 ── Concept と SFINAE と Detection Idiom" iconsizing="both"><div class="hint">Next<span class="arrow end"></span></div><div class="link">礦坑系列 ── Concept と SFINAE と Detection Idiom<!----></div></a></nav><!----><!----><!--]--></main><!--]--><footer class="vp-footer-wrapper" vp-footer><div class="vp-footer">The content on this site is all CC-BY-SA, or MIT/GPLv3+ dual license for code.</div><div class="vp-copyright">Copyright © 2025 Mes </div></footer></div><!--]--><!--]--><!--[--><!----><!--[--><!--]--><!--]--><!--]--></div>
    <script type="module" src="/assets/app-CHKuTo5H.js" defer></script>
  </body>
</html>
