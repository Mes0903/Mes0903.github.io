import{_ as n}from"./plugin-vue_export-helper-DlAUqK2U.js";import{e as i,g as a,h as l,f as r,i as s,r as p,o}from"./app-CHKuTo5H.js";const u={};function m(c,e){const t=p("center");return o(),i("div",null,[e[18]||(e[18]=a('<h2 id="ch2-os-structure" tabindex="-1"><a class="header-anchor" href="#ch2-os-structure"><span>Ch2 OS Structure</span></a></h2><h3 id="os-services" tabindex="-1"><a class="header-anchor" href="#os-services"><span>OS Services</span></a></h3><p>OS 就在幫 user 做事，有很多事一定要 OS 才能做，所以我們稱 OS 為 services</p><h4 id="user-interface" tabindex="-1"><a class="header-anchor" href="#user-interface"><span>User Interface</span></a></h4><p>Interface 大家應該都很熟悉，其實只分兩個：</p><ul><li><p>CLI (Command Line Interface)</p><p>下指令的介面，下的指令其實不是直接到 OS 手上，這個下指令的介面是一個程式，在 OS 的世界裡我們通稱為 Shell，常見的 shell 有 CShell、Bash</p><p>多了這一層，這一個介面的原因是一台電腦可能不只有一個使用者，每個使用者的習慣都不同，下 command 的方法可能也都不一樣，這樣就可以透過修改 Shell 設定檔的方式來達成</p><p>OS 還是以系統角度出發，System call 定義好就不能改了，而且是這台電腦上所有的程式都要 follow 的。但不同的使用者還是有不同的習慣，所以就需要一層 shell 在 OS 上面</p></li><li><p>GUI (Graphic User Interface)</p><p>圖形介面，基本概念就是透過 Icon，方便</p></li></ul><p>現在大多數的作業系統都同時有 CLI 和 GUI</p><h4 id="communication-models" tabindex="-1"><a class="header-anchor" href="#communication-models"><span>Communication Models</span></a></h4><p>這邊只是很簡單的講個基本概念，這裡的 Communication 指的不只是 Process 與 Process 之間，也可以是跨電腦的 level</p><p>但不管是哪種，我們都可以透過 memory 的使用把 Communication 切成兩大類：</p>',10)),l(t,null,{default:s(()=>e[0]||(e[0]=[r("img",{src:"https://github.com/Mes0903/MesBlog/blob/vuepress-theme-hope/src/OS/OS-Structured/image/1.png?raw=true"},null,-1)])),_:1}),e[19]||(e[19]=a('<br><ol><li><p>message passing</p><p>message 就是一般的概念，Process A 把 message 複製到 kernel，也就是 OS 的 memory，然後再讓 Process B 去複製去讀</p><p>簡單來講就是 memory copy，但這個 copy 不是直接複製過去的，而是先到 kernel 這樣繞了一圈的</p><p>要這樣做的原因主要是 Protection 的考量，每個 Process 都有自己的 base 與 limit，如果直接去 copy，那就越界了，因此這麼簡單的事情才也需要 system call</p><p>缺點是因為要一直 copy，所以速度相對來說比較慢</p></li><li><p>shared memory</p><p>兩個 Process 共享同一塊 memory，都有權利去讀寫這塊 memory，這樣兩個 Process 就可以利用這塊 memory 溝通</p><p>但這塊 memory 也是需要先跟 OS 講，透過 system call 來生成的</p><p>缺點就是會有 Synchronization 的問題，B 改完 A 可能沒發現資料已經被動過了</p><p>最常見的地方大概是 multi-thread programming</p></li></ol><p>用 memory 來分的理由應該顯而易見，因為 cpu 能直接 access 的就是 memory，但兩種都一樣要透過 OS</p><h3 id="os-application-interface" tabindex="-1"><a class="header-anchor" href="#os-application-interface"><span>OS-Application Interface</span></a></h3><p>一開始說 OS 提供了各式各樣的 service，這些服務提供的方式就是 function call，或我們叫它 API，這邊指的是 Program 層面，而不是剛剛說的 CLI 與 GUI 那些的</p><h4 id="system-call" tabindex="-1"><a class="header-anchor" href="#system-call"><span>System Call</span></a></h4><p>由 OS 提供的 function call 就是 system call，他是唯一的 interface，所以在 OS 上面會有一個 system call layer，因為它是直接與 OS 緊密連接在一起的，所以通常認為他是 OS 的一部份，處於最外層 interface 的那邊</p><p>因為是 OS，所以講究效能，因此 system call 有幾個特性：</p><ol><li><p>本身就是 software interrupt</p><p>這樣才有機會去切換 user mode 與 kernel mode，所以當你 call 了 system call 後，一定會進到 kernel mode</p></li><li><p>通常都是用 asm 寫的</p><p>在上層還有 shell 等其他東西，所以有其他東西會解決方便性的問題</p></li></ol><h4 id="api" tabindex="-1"><a class="header-anchor" href="#api"><span>API</span></a></h4><p>因為 system call 不好用，所以通常在上面會再多一層 API layer，全名叫 Application Program Interface，顧名思義就是為 Programming 方便而設計的，與 OS 沒有那麼緊密的關係</p><p>API 下面是 system call，system call 會下去呼叫 OS 裡面的 service routine</p><p>這些 API 的形式就是一堆 Library，事實上最常見的 C Library(libc) 就被定義為一個系統 API，但當然這不是唯一的，有些手機上的 API 就是使用 Java 寫的</p><p>API 與 System call 是不同 layer，但他們的角色並不是單純在做 translation 與 forwarding 而已，他們是兩個 layer，所以根本上的目的是不同的</p><p>也就是說一個 API 的 function call，可能會需要很多個 system call 來完成，這樣是一對多的關係；也有可能有那種完全不需要 system call 也能做完的 API，兩個 layer 的對應是沒有絕對的關聯性的</p><p>API 的目的是方便使用者使用，所以像 <code>abs()</code>，取絕對值的 function，就不需要使用到 system call，但 <code>malloc()</code> 與 <code>free()</code> 就都會用到 system call <code>brk()</code>，雖然他們的功能不一樣，但底下用到的 system call 是一樣的</p><p>要注意 Call 了 API 並不一定會進到 kernel mode，不一定會有 interrupt，因為不一定會用到 system call</p><p>比較常見的 API 有 Windows 上的 Win32 API、Unix 的 POSIX API 與 JVM 的 Java API</p>',18)),l(t,null,{default:s(()=>e[1]||(e[1]=[r("img",{src:"https://github.com/Mes0903/MesBlog/blob/vuepress-theme-hope/src/OS/OS-Structured/image/2.png?raw=true"},null,-1)])),_:1}),e[20]||(e[20]=a('<br><h4 id="parameters-passing" tabindex="-1"><a class="header-anchor" href="#parameters-passing"><span>Parameters Passing</span></a></h4><p>system call 一樣是 function，所以也會有參數需要傳遞，一般來說會有三種方法來傳遞參數：</p><ol><li><p>直接放在 registers</p></li><li><p>table in memory</p><p>當 parameters 很多的時候，系統可能會創建一個 data structure，然後把這個 data structure 的 pointer 傳進 function call</p><p>這個 function 拿到 pointer 後就可以去讀裡面的參數</p></li><li><p>stack</p><p>每個 Process 都有一塊 memory 叫 stack，可以把東西 push 進去和 pop 出來，有時參數也會 push 進 stack，然後透過 OS pop 出來，這樣來傳遞參數</p></li></ol><h3 id="os-structure" tabindex="-1"><a class="header-anchor" href="#os-structure"><span>OS Structure</span></a></h3><h4 id="simple-os-architecture" tabindex="-1"><a class="header-anchor" href="#simple-os-architecture"><span>Simple OS Architecture</span></a></h4><p>最早期的 OS 幾乎沒有架構，除了 Driver 與 OS，其他東西都混在一起，因為那時候最重要的是 User friendly，例如早期的 MS-DOS 與 Unix</p><p>因此就非常的不安全，且很難 maintain，所以早期電腦才會有那麼多的 worm</p>',8)),l(t,null,{default:s(()=>e[2]||(e[2]=[r("img",{src:"https://github.com/Mes0903/MesBlog/blob/vuepress-theme-hope/src/OS/OS-Structured/image/3.png?raw=true"},null,-1)])),_:1}),e[21]||(e[21]=r("br",null,null,-1)),e[22]||(e[22]=r("h4",{id:"layered-os-architecture",tabindex:"-1"},[r("a",{class:"header-anchor",href:"#layered-os-architecture"},[r("span",null,"Layered OS Architecture")])],-1)),e[23]||(e[23]=r("p",null,"很快地大家就發現上面那個不是一個很好的 solution，至少以系統的角度不是，所以就有人提出了 Layer 的概念",-1)),e[24]||(e[24]=r("p",null,"因為 OS 是個很大的 Program，裡面會有很多的 subsystem，像是 I/O、memory、driver 等等，OS 執行起來是很多個 Process 被執行，然後彼此互相溝通",-1)),e[25]||(e[25]=r("p",null,"因此就把這些 subsystem 分層，外面的 Layer 可以 call 裡面的，但裡面的不能 call 外面的，以下圖來說就是 I/O 可以 call Memory，但 Memory 不能 call I/O，所以在設計上就不應該提供後面那個 function call，因為會破壞定義好的 layer",-1)),l(t,null,{default:s(()=>e[3]||(e[3]=[r("img",{src:"https://github.com/Mes0903/MesBlog/blob/vuepress-theme-hope/src/OS/OS-Structured/image/4.png?raw=true"},null,-1)])),_:1}),e[26]||(e[26]=r("br",null,null,-1)),e[27]||(e[27]=r("p",null,"好處是比較好 debug 和 maintain 了，因為一個 program 在執行時會有 call path，所以我們可以一層一層去 test",-1)),e[28]||(e[28]=r("p",null,"但缺點是比較沒有效率，因為有 layer，所以就跟 socket programming 的缺點類似，可能會有很多 memory copy，沒辦法直接跳到某一個地方去 call function，另外有些時候 layer 會很難定義，像是上面那個例子，Memory 可能也會 call 到 I/O",-1)),e[29]||(e[29]=r("h4",{id:"microkernel-os-architecture",tabindex:"-1"},[r("a",{class:"header-anchor",href:"#microkernel-os-architecture"},[r("span",null,"Microkernel OS Architecture")])],-1)),e[30]||(e[30]=r("p",null,"Microkernel 主要的想法是 kernel 的程式碼應該要越少越好，因為這樣比較 reliable，因為只要那些 code 沒有 bug 就好",-1)),e[31]||(e[31]=r("p",null,"此時就有 modulize 的概念進來了，因為他把每一個 subsystem 都變成一個個的 module，中間的 kernel 只是負責去溝通這些 module，看怎麼傳輸，怎麼 handle interface 等等",-1)),e[32]||(e[32]=r("p",null,"所以如果系統裡面有新的 I/O Device，甚至是新的 Memory Management，想要把舊的換掉，只要把原本的 Module 換掉，把新的 hook 上來就好，他並不屬於 OS 的一部份",-1)),e[33]||(e[33]=r("p",null,"當時比較嚴謹的定義是只要是在 kernel 外面的，都算在 user space，所以下圖的 I/O Manager、Graphics Subsystem 等都跟普通的 user program 一樣，也因此他 crash 也沒關係",-1)),l(t,null,{default:s(()=>e[4]||(e[4]=[r("img",{src:"https://github.com/Mes0903/MesBlog/blob/vuepress-theme-hope/src/OS/OS-Structured/image/5.png?raw=true"},null,-1)])),_:1}),e[34]||(e[34]=r("br",null,null,-1)),e[35]||(e[35]=r("p",null,"缺點很明顯是效能又會變得更慢，因為每個 subsystem 都是在 user space，所以每次 subsystem 之間在溝通的時候都要透過 kernel，這都是 system call，前面的不管是 Layered 或 Simple，都是在 kernel space 裡面，所以在溝通的時候不會有 Interrupt，直接就可以 call",-1)),e[36]||(e[36]=r("p",null,"另外因為有 Synchronization 的問題，所以她溝通的方法是 message passing，這樣參數一定要傳遞，所以會有 memory copy，就會變慢",-1)),e[37]||(e[37]=r("h4",{id:"modular-os-architecture",tabindex:"-1"},[r("a",{class:"header-anchor",href:"#modular-os-architecture"},[r("span",null,"Modular OS Architecture")])],-1)),e[38]||(e[38]=r("p",null,"這是現在最常見的一個，因為就像 OO 概念一樣，跟剛剛一樣，會有很多 subsystem，用 OO 的方式去寫 OS，差別是這些全部都在 kernel space，所以彈性就會比較高，至少在溝通就不需要透過 message passing",-1)),e[39]||(e[39]=r("p",null,"Modular 有一個很重要的點是它 loadable，也就是可以去 load kernel module 進去，這樣便能夠改變 OS 的 feature",-1)),l(t,null,{default:s(()=>e[5]||(e[5]=[r("img",{src:"https://github.com/Mes0903/MesBlog/blob/vuepress-theme-hope/src/OS/OS-Structured/image/6.png?raw=true"},null,-1)])),_:1}),e[40]||(e[40]=a('<br><p>kernel module 的運作可以看上圖中間右邊，只要是 system call 就會有 interrupt，interrupt 會到一個 table，Signal 的話是 interrupt vector，而 Trap 這邊也會有 interrupt table，前面說過通常是用 switch case 的方式來做，所以這 table 會有些 entry 是空的</p><p>所以這樣你用 administration permission 的時候，就可以 insert module，也就是去改 table 的 entry，如此一來便能定義新的 system call 了</p><p>但最常見的做法其實是 replace，例如本來有個 system call 叫 <code>fopen</code>，然後我們 insert 一個 override，去覆寫那個 entry，第一行可能偷偷加上個 <code>print file name</code>，然後後面再把原本 open file 的 code 貼上去，這樣就不會影響到系統運作，且成功改寫 system call 了，這個技巧可以攔截 system call，幫助我們 debug</p><h3 id="virtual-machine" tabindex="-1"><a class="header-anchor" href="#virtual-machine"><span>Virtual Machine</span></a></h3><p>VM 的概念其實很早就出來了，因為早在大家思考 OS 設計前就有一台電腦多使用者的需求了，所以就有人想要用 VM 的方式來解決這個問題</p><p>VM 可以把底層的架構抽象化，在底層已經灌了一個 OS 的情況下，我們可以在上層透過 VM 的技術再灌一個 OS，然後把既有的 OS 抽象成好像不存在一樣，這樣 VM 的環境裡面就好像它本身就是一台獨立的電腦，原來的 OS 我們稱他為 host，VM 的 OS 我們稱它為 guest</p><p>虛擬化技術的困難處在於我們的 software 在設計的時候自己就有些對於硬體的 assumption，其中一個很大的困擾的是 critical instruction，它不是 privileged instruction，但這種 instruction 很特別，它在 user mode 和 kernel mode 的執行結果不一樣</p><p>下圖左方是原本正常的狀況，硬體上方直接就是 OS，而右方則是有 VM 的狀況，硬體上會有原本的 OS 和一些管理的軟體，然後再上面我們可以去創建 VM，VM 與 VM 間並不知道彼此的存在</p>',9)),l(t,null,{default:s(()=>e[6]||(e[6]=[r("img",{src:"https://github.com/Mes0903/MesBlog/blob/vuepress-theme-hope/src/OS/OS-Structured/image/7.png?raw=true"},null,-1)])),_:1}),e[41]||(e[41]=a('<br><p>另外前面提到的虛擬化指的並不是去修改上圖 VM 上方的 kernel，而是指如何在硬體上方增加一個 layer 讓電腦可以同時執行很多個 VM</p><p>最主要的一個困難點是 user space 與 kernel space 的問題，kernel 在運作的時候會假設自己在 kernel space，但在 VM 的設計下，VM 上的 kernel 其實是裝在 user space 的，所以當他執行 privileged instruction 的時候就會出現問題，因為實際上它是在 user space</p><p>解決方法有很多種，最常見的方法，在 VM 的 kernel 要執行時因為是在整個電腦的 user space，所以會丟出 exception 告訴我們這是一個非法的指令，所以會被擋掉，但在被檔的時候，這個 interrupt 會先回到 OS，這時他就知道上面那個 VM 要執行 privileged instruction，此時 OS 就可以幫他執行，所以 OS 就再 call 一次剛剛 VM 想執行的 interrupt，但這次就會過了</p><h4 id="usage-of-virtual-machine" tabindex="-1"><a class="header-anchor" href="#usage-of-virtual-machine"><span>Usage of Virtual Machine</span></a></h4><p>使用 VM 有很多好處，像是</p><ol><li><p>protection</p><p>VM 可以保護我們的 OS，因為它本身就是一個獨立的環境</p></li><li><p>兼容性</p><p>有些軟體可能會有特定需求的環境，例如一定要 windows98，但我們也需要用其他的軟體，不能直接把整台電腦換成指定的環境，所以我們可以用 VM 來解決這個問題</p></li><li><p>開發用</p><p>當我們想做 kernel 的研究時，因為 kernel 一有 bug 就會整個 crash，如果用實機來研究，要一直重新開機，硬體也很有可能會壞掉，但如果用 VM 就沒這個問題了</p></li><li><p>honey bound</p><p>在做資安時很常要研究一台電腦是如何被攻擊的，如果用實機，電腦被攻擊後可能整個資料就被銷毀了，但用 VM 就可以解決這個問題，我們可以把資料存在真正的 OS 上</p></li><li><p>雲端計算</p><p>現在大家講求的是資源的共享，自己的電腦資源有限，這個技術的重點是 resource sharing，一台機器會被切成很多台 VM 供大家使用，然後也方便管理</p></li></ol><h4 id="virtualization" tabindex="-1"><a class="header-anchor" href="#virtualization"><span>Virtualization</span></a></h4>',8)),r("ol",null,[r("li",null,[e[8]||(e[8]=r("p",null,"Full Virtualization",-1)),e[9]||(e[9]=r("p",null,"Full Virtualization 代表只要是可以裝在一般電腦的 OS，也可以直接裝在 VM 裡面，不需要調整，OS 完全不會知道自己是裝在 VM 裡面，所以叫做 Full Virtualization",-1)),l(t,null,{default:s(()=>e[7]||(e[7]=[r("img",{src:"https://github.com/Mes0903/MesBlog/blob/vuepress-theme-hope/src/OS/OS-Structured/image/8.png?raw=true"},null,-1)])),_:1})]),r("li",null,[e[11]||(e[11]=r("p",null,"Para-virtualization",-1)),e[12]||(e[12]=r("p",null,"差別在會多一個 global zone，我們通常叫他 manager，這是個特殊的程式，他知道所有的 VM 的存在，另外 裝在上面的 OS(guest) 也需要被修改，好處是這樣就可以開一些後門了，速度也不一定會比較慢",-1)),l(t,null,{default:s(()=>e[10]||(e[10]=[r("img",{src:"https://github.com/Mes0903/MesBlog/blob/vuepress-theme-hope/src/OS/OS-Structured/image/9.png?raw=true"},null,-1)])),_:1})]),r("li",null,[e[14]||(e[14]=r("p",null,"Java VM",-1)),e[15]||(e[15]=r("p",null,"Java 本身執行的方式就像執行在一個 VM 上，但相對來說這個 VM 單純很多，因為只是要執行 instruction",-1)),e[16]||(e[16]=r("p",null,"Java 編譯完後會有自己的 binary code，它不是 x86，也不是 misc，也不是任何一個硬體的指令，它是 JVM 上的 bytecode",-1)),e[17]||(e[17]=r("p",null,"當要在電腦執行時，它會再根據電腦的環境往下做 translation，因為 JVM 類似一個 OS，所以對於這些 code 所使用的 memory 會有很好的 isolation，也就是說再怎麼寫，它仍然只會使用那個 VM 裡面的 memory，所以對於 host OS 而言，裡面的 code 不管怎麼執行都不太會影響到別人",-1)),l(t,null,{default:s(()=>e[13]||(e[13]=[r("img",{src:"https://github.com/Mes0903/MesBlog/blob/vuepress-theme-hope/src/OS/OS-Structured/image/10.png?raw=true"},null,-1)])),_:1})])])])}const g=n(u,[["render",m],["__file","index.html.vue"]]),O=JSON.parse(`{"path":"/OS/OS-Structured/","title":"Ch2 OS Structure","lang":"en-US","frontmatter":{"title":"Ch2 OS Structure","date":"2021-12-20T00:00:00.000Z","tag":"OS","category":"OS","order":2,"description":"Ch2 OS Structure OS Services OS 就在幫 user 做事，有很多事一定要 OS 才能做，所以我們稱 OS 為 services User Interface Interface 大家應該都很熟悉，其實只分兩個： CLI (Command Line Interface) 下指令的介面，下的指令其實不是直接到 OS 手上，這個...","head":[["meta",{"property":"og:url","content":"https://mes0903.github.io/OS/OS-Structured/"}],["meta",{"property":"og:site_name","content":"Mes's Blog"}],["meta",{"property":"og:title","content":"Ch2 OS Structure"}],["meta",{"property":"og:description","content":"Ch2 OS Structure OS Services OS 就在幫 user 做事，有很多事一定要 OS 才能做，所以我們稱 OS 為 services User Interface Interface 大家應該都很熟悉，其實只分兩個： CLI (Command Line Interface) 下指令的介面，下的指令其實不是直接到 OS 手上，這個..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"en-US"}],["meta",{"property":"og:updated_time","content":"2025-02-26T11:24:15.000Z"}],["meta",{"property":"article:tag","content":"OS"}],["meta",{"property":"article:published_time","content":"2021-12-20T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2025-02-26T11:24:15.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Ch2 OS Structure\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2021-12-20T00:00:00.000Z\\",\\"dateModified\\":\\"2025-02-26T11:24:15.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Mes\\",\\"url\\":\\"https://mes0903.github.io\\"}]}"]]},"git":{"createdTime":1740149490000,"updatedTime":1740569055000,"contributors":[{"name":"Mes","username":"Mes","email":"mes900903@gmail.com","commits":4,"url":"https://github.com/Mes"}]},"readingTime":{"minutes":12.02,"words":3607},"filePathRelative":"OS/OS-Structured/README.md","localizedDate":"December 20, 2021","excerpt":"","autoDesc":true}`);export{g as comp,O as data};
