import{_ as c}from"./plugin-vue_export-helper-DlAUqK2U.js";import{e as i,g as t,h as l,f as o,i as a,j as d,r as n,o as r}from"./app-CWQAzWd7.js";const p={},m={class:"MathJax",jax:"SVG",style:{position:"relative"}},u={style:{"vertical-align":"0"},xmlns:"http://www.w3.org/2000/svg",width:"7.008ex",height:"1.914ex",role:"img",focusable:"false",viewBox:"0 -846 3097.5 846","aria-hidden":"true"},T={class:"MathJax",jax:"SVG",style:{position:"relative"}},S={style:{"vertical-align":"0"},xmlns:"http://www.w3.org/2000/svg",width:"2.919ex",height:"1.887ex",role:"img",focusable:"false",viewBox:"0 -833.9 1290.1 833.9","aria-hidden":"true"};function Q(g,e){const s=n("center");return r(),i("div",null,[e[13]||(e[13]=t('<h2 id="_12-supervisor-level-isa-version-1-13" tabindex="-1"><a class="header-anchor" href="#_12-supervisor-level-isa-version-1-13"><span>12. Supervisor-Level ISA, Version 1.13</span></a></h2><h3 id="_12-1-1-supervisor-status-sstatus-register" tabindex="-1"><a class="header-anchor" href="#_12-1-1-supervisor-status-sstatus-register"><span>12.1.1. Supervisor Status (<code>sstatus</code>) Register</span></a></h3><p><code>sstatus</code> 暫存器是一個 SXLEN-bit read/write 的暫存器，用來追蹤處理器目前的狀態，為 <code>mstatus</code> 的子集</p><p>當 <code>SXLEN</code> 為 32 時，格式如下圖：</p>',4)),l(s,null,{default:a(()=>e[0]||(e[0]=[o("img",{src:"https://github.com/Mes0903/MesBlog/blob/vuepress-theme-hope/src/risc-v/Supervisor-Level-ISA/image/sstatus1.png?raw=true"},null,-1)])),_:1}),e[14]||(e[14]=o("br",null,null,-1)),e[15]||(e[15]=o("p",null,[d("當 "),o("code",null,"SXLEN"),d(" 為 64 時格式如下圖：")],-1)),l(s,null,{default:a(()=>e[1]||(e[1]=[o("img",{src:"https://github.com/Mes0903/MesBlog/blob/vuepress-theme-hope/src/risc-v/Supervisor-Level-ISA/image/sstatus2.png?raw=true"},null,-1)])),_:1}),e[16]||(e[16]=t('<br><ul><li><code>SPP</code><ul><li><code>SPP</code> 位元表示 hart 在進入 S-mode 之前執行的特權等級</li><li>當 Trap 發生時，如果其源自 U-mode，則 <code>SPP</code> 設定為 0，否則為 1</li><li>當執行 <code>SRET</code> 指令從 trap handler 返回時 <ul><li>如果 <code>SPP</code> 為 0，則特權等級會被設為 U-mode</li><li>否則設為 S-mode 並將 <code>SPP</code> 設為 0</li></ul></li></ul></li><li><code>SIE</code><ul><li>用來啟用或禁用 S-mode 下的所有中斷 <ul><li>清 0 時 S-mode 下不會產生中斷</li></ul></li><li>如果 hart 運行在 U-mode，<code>SIE</code> 的值會被忽略，且會啟用 S-mode 的中斷</li><li>supervisor 可以利用 <code>sie</code> CSR 來停用單一的中斷來源</li></ul></li><li><code>SPIE</code><ul><li>用來紀錄在進入 S-mode 之前是否啟用了 S-mode 下的中斷</li><li>當 Trap 進入 S-mode 時，<code>SPIE</code> 被設為 <code>SIE</code>，並且 <code>SIE</code> 被設為 0</li><li>執行 <code>SRET</code> 指令時，<code>SIE</code> 被設為 <code>SPIE</code>，然後 <code>SPIE</code> 被設為 1</li></ul></li></ul><h4 id="_12-1-1-1-base-isa-control-in-sstatus-register" tabindex="-1"><a class="header-anchor" href="#_12-1-1-1-base-isa-control-in-sstatus-register"><span>12.1.1.1. Base ISA Control in <code>sstatus</code> Register</span></a></h4><p><code>UXL</code> 欄位控制 U-mode 的 <code>XLEN</code> 值，稱為 <code>UXLEN</code>，其可能與 S-mode 的 <code>XLEN</code> 值不同(稱為 <code>SXLEN</code>)。 簡單來說：</p><ul><li><code>UXLEN</code> 表示 U-mode 的位元寬度，決定 U-mode 下的有效位址長度</li><li><code>SXLEN</code> 表示 S-mode 或 M-mode 下的位元寬度，決定系統支援的完整位址空間</li></ul><p><code>UXL</code> 的編碼與 <code>misa</code> 內的 <code>MXL</code> 相同，<code>MXL</code> 的編碼如下表：</p>',6)),l(s,null,{default:a(()=>e[2]||(e[2]=[o("table",null,[o("thead",null,[o("tr",null,[o("th",null,"MXL"),o("th",null,"XLEN")])]),o("tbody",null,[o("tr",null,[o("td",null,"1"),o("td",null,"32")]),o("tr",null,[o("td",null,"2"),o("td",null,"64")]),o("tr",null,[o("td",null,"3"),o("td",null,"128")])])],-1)])),_:1}),e[17]||(e[17]=t("<p>當 <code>SXLEN</code> 為 32 時，<code>UXL</code> 欄位不存在，此時 <code>UXLEN</code> 為 32。 當 <code>SXLEN</code> 為 64 時，它是一個 WARL 字段，值為當前 <code>UXLEN</code> 值的編碼。 具體來說，UXL 可能被實作為一個唯讀的字段，其值始終保證 <code>UXLEN = SXLEN</code></p><p>如果 <code>UXLEN ≠ SXLEN</code>，則在 narrower mode 下執行的指令必須忽略配置的 <code>XLEN</code> 以上的來源暫存器運算元，並且必須對結果進行 sign-extend 以填充目標暫存器中最寬的 <code>XLEN</code></p>",2)),o("p",null,[e[5]||(e[5]=d("如果 ")),e[6]||(e[6]=o("code",null,"UXLEN < SXLEN",-1)),e[7]||(e[7]=d("，U-mode 下的 instruction-fetch 位址，和 load/store 的有效位址以 ")),o("mjx-container",m,[(r(),i("svg",u,e[3]||(e[3]=[t('<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msup"><g data-mml-node="mn"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g><g data-mml-node="TeXAtom" transform="translate(533,363) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mtext"><path data-c="55" d="M128 622Q121 629 117 631T101 634T58 637H25V683H36Q57 680 180 680Q315 680 324 683H335V637H302Q262 636 251 634T233 622L232 418V291Q232 189 240 145T280 67Q325 24 389 24Q454 24 506 64T571 183Q575 206 575 410V598Q569 608 565 613T541 627T489 637H472V683H481Q496 680 598 680T715 683H724V637H707Q634 633 622 598L621 399Q620 194 617 180Q617 179 615 171Q595 83 531 31T389 -22Q304 -22 226 33T130 192Q129 201 128 412V622Z"></path><path data-c="58" d="M270 0Q252 3 141 3Q46 3 31 0H23V46H40Q129 50 161 88Q165 94 244 216T324 339Q324 341 235 480T143 622Q133 631 119 634T57 637H37V683H46Q64 680 172 680Q297 680 318 683H329V637H324Q307 637 286 632T263 621Q263 618 322 525T384 431Q385 431 437 511T489 593Q490 595 490 599Q490 611 477 622T436 637H428V683H437Q455 680 566 680Q661 680 676 683H684V637H667Q585 634 551 599Q548 596 478 491Q412 388 412 387Q412 385 514 225T620 62Q628 53 642 50T695 46H726V0H717Q699 3 591 3Q466 3 445 0H434V46H440Q454 46 476 51T499 64Q499 67 463 124T390 238L353 295L350 292Q348 290 343 283T331 265T312 236T286 195Q219 88 218 84Q218 70 234 59T272 46H280V0H270Z" transform="translate(750,0)"></path><path data-c="4C" d="M128 622Q121 629 117 631T101 634T58 637H25V683H36Q48 680 182 680Q324 680 348 683H360V637H333Q273 637 258 635T233 622L232 342V129Q232 57 237 52Q243 47 313 47Q384 47 410 53Q470 70 498 110T536 221Q536 226 537 238T540 261T542 272T562 273H582V268Q580 265 568 137T554 5V0H25V46H58Q100 47 109 49T128 61V622Z" transform="translate(1500,0)"></path><path data-c="45" d="M128 619Q121 626 117 628T101 631T58 634H25V680H597V676Q599 670 611 560T625 444V440H585V444Q584 447 582 465Q578 500 570 526T553 571T528 601T498 619T457 629T411 633T353 634Q266 634 251 633T233 622Q233 622 233 621Q232 619 232 497V376H286Q359 378 377 385Q413 401 416 469Q416 471 416 473V493H456V213H416V233Q415 268 408 288T383 317T349 328T297 330Q290 330 286 330H232V196V114Q232 57 237 52Q243 47 289 47H340H391Q428 47 452 50T505 62T552 92T584 146Q594 172 599 200T607 247T612 270V273H652V270Q651 267 632 137T610 3V0H25V46H58Q100 47 109 49T128 61V619Z" transform="translate(2125,0)"></path><path data-c="4E" d="M42 46Q74 48 94 56T118 69T128 86V634H124Q114 637 52 637H25V683H232L235 680Q237 679 322 554T493 303L578 178V598Q572 608 568 613T544 627T492 637H475V683H483Q498 680 600 680Q706 680 715 683H724V637H707Q634 633 622 598L621 302V6L614 0H600Q585 0 582 3T481 150T282 443T171 605V345L172 86Q183 50 257 46H274V0H265Q250 3 150 3Q48 3 33 0H25V46H42Z" transform="translate(2806,0)"></path></g></g></g></g></g>',1)]))),e[4]||(e[4]=o("mjx-assistive-mml",{unselectable:"on",display:"inline"},[o("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[o("msup",null,[o("mn",null,"2"),o("mrow",{"data-mjx-texclass":"ORD"},[o("mtext",null,"UXLEN")])])])],-1))]),e[8]||(e[8]=d(" 模除。 換句話說，因為此時 U-mode 的指令和記憶體存取位址的有效位元數比 S-mode 的位址還短，因此只能存取較低範圍的記憶體"))]),e[18]||(e[18]=o("p",null,[d("舉個例子，當 "),o("code",null,"UXLEN"),d(" 為 32，"),o("code",null,"SXLEN"),d(" 為 64 的情況下，U-mode 下的程式無論怎麼操作記憶體，都只能看到低 4GiB 的記憶體範圍，換句話說 U-mode 的記憶體存取是 32 位元地址空間內的操作，而不是完整的 64 位元地址空間")],-1)),o("blockquote",null,[o("p",null,[o("mjx-container",T,[(r(),i("svg",S,e[9]||(e[9]=[t('<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msup"><g data-mml-node="mn"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g><g data-mml-node="TeXAtom" transform="translate(533,363) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mn"><path data-c="33" d="M127 463Q100 463 85 480T69 524Q69 579 117 622T233 665Q268 665 277 664Q351 652 390 611T430 522Q430 470 396 421T302 350L299 348Q299 347 308 345T337 336T375 315Q457 262 457 175Q457 96 395 37T238 -22Q158 -22 100 21T42 130Q42 158 60 175T105 193Q133 193 151 175T169 130Q169 119 166 110T159 94T148 82T136 74T126 70T118 67L114 66Q165 21 238 21Q293 21 321 74Q338 107 338 175V195Q338 290 274 322Q259 328 213 329L171 330L168 332Q166 335 166 348Q166 366 174 366Q202 366 232 371Q266 376 294 413T322 525V533Q322 590 287 612Q265 626 240 626Q208 626 181 615T143 592T132 580H135Q138 579 143 578T153 573T165 566T175 555T183 540T186 520Q186 498 172 481T127 463Z"></path><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z" transform="translate(500,0)"></path></g></g></g></g></g>',1)]))),e[10]||(e[10]=o("mjx-assistive-mml",{unselectable:"on",display:"inline"},[o("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[o("msup",null,[o("mn",null,"2"),o("mrow",{"data-mjx-texclass":"ORD"},[o("mn",null,"32")])])])],-1))]),e[11]||(e[11]=d(" = 4GiB"))])]),e[19]||(e[19]=t(`<h5 id="hint-相關" tabindex="-1"><a class="header-anchor" href="#hint-相關"><span>HINT 相關</span></a></h5><p>HINT 指令是沒有實際運算效果，但可能被用來提供某些優化或調整的指令。 某些 HINT 指令會被編碼為整數計算指令，其會利用當下的值覆蓋目標暫存器值</p><p>此時若 <code>XLEN &lt; SXLEN</code> 且目標暫存器 <code>SXLEN .. XLEN</code> 處的位元與 <code>XLEN - 1</code> 處的不一致，則目標暫存器 <code>SXLEN .. XLEN</code> 處的位元會依照 implementation-defined 的方式，將其值保留或以 <code>XLEN - 1</code> 處的位元延展覆蓋</p><p>舉個例子，例如 <code>c.addi x8, 0</code> 這個指令，其等同於 <code>addi x8 x8 0</code>，也就是 <code>x8 = x8</code>，這是一個 HINT 指令，對計算沒有影響。 假設 U-mode 運行在 <code>XLEN = 32</code>，但暫存器是 64 位元的(<code>SXLEN = 64</code>)，而假設目標暫存器 <code>x8</code> 的內容如下：</p><div class="language-assembly line-numbers-mode" data-highlighter="shiki" data-ext="assembly" data-title="assembly" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>64-bit register (SXLEN=64, XLEN=32)</span></span>
<span class="line"><span>┌──────────────────────────┬────────────────────────┐</span></span>
<span class="line"><span>│ 高 32 位元 (SXLEN..XLEN) │ 低 32 位元 (XLEN)      │</span></span>
<span class="line"><span>│  0xF0000000              │  0x12345678            │</span></span>
<span class="line"><span>└──────────────────────────┴────────────────────────┘</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>其中低 32 位元(<code>0x12345678</code>) 是有效值，而高 32 位元(<code>0xF0000000</code>) 是超出 <code>XLEN</code> 的部分，內容可能來自之前的運算</p><p>當執行 HINT 指令 <code>c.addi x8, 0</code> 時</p><ul><li>低 32 位元(<code>XLEN</code>) 會保持不變(<code>0x12345678</code>)</li><li>高 32 位元 (<code>SXLEN..XLEN</code>) 有兩種可能的行為： <ul><li>不變，保持 <code>0xF0000000</code></li><li>以 <code>XLEN-1</code> 位元的值延展覆蓋為 <code>0x00000000</code></li></ul></li></ul><p>這允許實作上省略 HINT 指令中目標暫存器的寫回(writeback)，其也可以選擇將部分 HINT 指令像一般整數運算指令一樣執行。 這種選擇只會影響到 S-mode 下 <code>SXLEN &gt; UXLEN</code> 的情況，對 U-mode 來說這個行為完全不可見</p><p>一般的整數運算指令(如 <code>addi x8, 0</code>) 都會：</p><ul><li>讀取 <code>x8</code> 的值</li><li>執行計算(這裡是 <code>+0</code>，所以結果不變)</li><li>寫回 <code>x8</code></li></ul><p>但對於 HINT 指令，CPU 可以選擇「完全不寫回 <code>x8</code>」，因為它不影響計算結果</p><h4 id="_12-1-1-2-memory-privilege-in-sstatus-register-mxr-與-sum" tabindex="-1"><a class="header-anchor" href="#_12-1-1-2-memory-privilege-in-sstatus-register-mxr-與-sum"><span>12.1.1.2. Memory Privilege in <code>sstatus</code> Register (<code>MXR</code> 與 <code>SUM</code>)</span></a></h4><p><code>MXR</code>(Make eXecutable Readable) 位元控制讀取(load) 虛擬記憶體的權限</p><ul><li><code>MXR = 0</code><ul><li>只允許讀取標記為可讀(<code>R=1</code>)的 page</li></ul></li><li><code>MXR = 1</code><ul><li>允許讀取可讀(<code>R=1</code>) 或可執行(<code>X=1</code>) 的 page</li></ul></li></ul><p>當 page-based 的虛擬記憶體未啟用時(<code>satp.MODE = Bare</code>)，<code>MXR</code> 沒有作用</p><p><code>SUM</code>(permit Supervisor User Memory access) 位元控制 S-mode 下存取 U-mode page 的權限</p><ul><li><code>SUM = 0</code><ul><li>S-mode 無法存取 「U-mode 可存取(<code>U=1</code>)」的 page</li><li>如果嘗試存取，會產生錯誤(fault)</li></ul></li><li><code>SUM = 1</code><ul><li>允許 S-mode 存取 <code>U=1</code> 的 page</li></ul></li></ul><p>當 paged-based 的虛擬記憶體未啟用，或者運行在 U-mode 時，<code>SUM</code> 沒有作用。 另外無論 <code>SUM</code> 的狀態為何，S-mode 下都無法執行 U-mode page 中的指令</p><p>如果 <code>satp.MODE</code> 是唯讀的 0 (<code>satp.MODE=0</code>)，則 <code>SUM</code> 也是唯讀的 0，這表示在不支援 page 的系統上，S-mode 永遠無法存取 U-mode 記憶體</p><p>page table entry 可以參考下圖(Sv32 page table entry)</p>`,21)),l(s,null,{default:a(()=>e[12]||(e[12]=[o("img",{src:"https://github.com/Mes0903/MesBlog/blob/vuepress-theme-hope/src/risc-v/Supervisor-Level-ISA/image/sv32_page_table_entry.png?raw=true"},null,-1)])),_:1}),e[20]||(e[20]=t('<br><p><code>SUM</code> 的機制可以防止 S-mode 下的軟體意外存取 user memory，作業系統可以在 <code>SUM=0</code> 的情況下執行大部分的程式碼，並在少數需要訪問 user memory 的情況下再暫時設定 <code>SUM</code></p><p><code>SUM</code> 的機制不允許 S-mode 軟體執行 user code pages 中的指令。 但這在其他場景下通常也是個不合法的操作，在 POSIX 環境中也禁止 S-mode 執行 U-mode memory page 中的指令，因為如果 S-mode 中存在任意代碼執行(Arbitrary Code Execution, ACE) 的漏洞，那麼這類漏洞將變得更容易被利用，特別是當攻擊者能夠將惡意代碼存放在 U-mode 可存取的記憶體 (user buffer) 並在攻擊過程中執行它</p><p>但是有些 non-POSIX 的單一位址空間(Single Address Space) 作業系統允許部分軟體在 S-mode 下執行 U-mode program，其大部分程式都運行在 U-mode 下，並和 kernel 共用同一個位址空間。 在這種情況下，可以通過映射相同的物理記憶體到不同的虛擬記憶體頁面，並設定不同的權限來允許 S-mode 軟體部分執行 U-mode 的程式碼</p><h4 id="_12-1-1-3-endianness-control-in-sstatus-register-ube" tabindex="-1"><a class="header-anchor" href="#_12-1-1-3-endianness-control-in-sstatus-register-ube"><span>12.1.1.3. Endianness Control in <code>sstatus</code> Register (<code>UBE</code>)</span></a></h4><p><code>UBE</code> 為原是個 WARL 的字段，用來控制 U-mode 下記憶體存取的位元組順序(Endianness)，其可能與 S-mode 下的位元組順序不同。 實作上可能會把 UBE 設成一個唯讀的字段，使其始終與 S-mode 的位元組順序相同</p><ul><li><code>UBE = 0</code>：使用小端序(little-endian)</li><li><code>UBE = 1</code>：使用大端序(big-endian)</li></ul><p>另外</p><ul><li>instruction-fetch 不受 <code>UBE</code> 的影響 <ul><li>其屬於隱式(implicit) 記憶體存取，永遠是小端序(little-endian)</li></ul></li><li><code>UBE</code> 不影響 S-mode 相關的隱式記憶體存取 <ul><li>如 S-mode 讀取 page table 或其他記憶體管理資料結構，這些記憶體存取總是使用 S-mode 的位元組順序</li></ul></li></ul><p>標準的 RISC-V ABI 只能是純小端 (Little-Endian, LE) 或純大端 (Big-Endian, BE)，不允許混合大小端(mixing endianness)。 儘管標準 ABI 只能是純 LE 或純 BE，但 RISC-V 還是允許作業系統支援與自身大小端不同的 U-mode 應用程式</p><h4 id="_12-1-1-4-previous-expected-landing-pad-elp-state-in-sstatus-register" tabindex="-1"><a class="header-anchor" href="#_12-1-1-4-previous-expected-landing-pad-elp-state-in-sstatus-register"><span>12.1.1.4. Previous Expected Landing Pad (ELP) State in <code>sstatus</code> Register</span></a></h4><p><code>SPELP</code> 欄位由 Zicflip 擴充指令集引入，用途與控制流完整性(CFI) 有關。 在 S-mode 下存取 <code>SPELP</code> 欄位時，會根據 <code>V</code> 位元的狀態來決定要存取 <code>mstatus.SPELP</code> 還是 <code>vsstatus.SPELP</code>：</p><ul><li><code>V=0</code>(非虛擬化模式)：存取 <code>mstatus.SPELP</code></li><li><code>V=1</code>(虛擬化模式)：存取 <code>vsttatus.SPELP</code></li></ul><h4 id="_12-1-1-5-double-trap-control-in-sstatus-register" tabindex="-1"><a class="header-anchor" href="#_12-1-1-5-double-trap-control-in-sstatus-register"><span>12.1.1.5. Double Trap Control in <code>sstatus</code> Register</span></a></h4><p><code>SDT</code>(S-mode-disable-trap) 是一個 WARL 的欄位，由 Ssdbltrp 擴充指令集引入，用來解決 S-mode 以下 double trap 的問題</p><blockquote><p>double trap 指的是，當 Trap handler 正在處理異常(Trap) 且正處於 non-reentrant 的狀態時，發生了另一個異常，導致其無法正常處理</p></blockquote><p>當 <code>SDT</code> 位元透過 CSR write 顯式設為 1 時，無論該操作是否在同一寫入中試圖設定 <code>SIE</code>，<code>SIE</code> 都會被強制清 0，這代表 S-mode 將無法接受中斷。 而執行 <code>SRET</code> 指令 <code>SDT</code> 會被清 0</p><p><code>SIE=1</code> 只能發生在 <code>SDT=0</code> 的情況下，如果 <code>SDT=1</code>，則 <code>SIE</code> 無法手動設為 <code>1</code>，這確保在 <code>SDT=1</code> 時 S-mode 不會收到新的中斷</p><p>當系統發生異常(Trap) 時，如果 <code>SDT=0</code>，則 <code>SDT</code> 會被自動設定為 <code>1</code>，之後異常會正常傳遞到 S-mode。 然而如果 <code>SDT</code> 已經是 <code>1</code>(代表 S-mode 已經在處理異常)，則這是一個意外異常(unexpected trap)，當意外異常發生時，其會產生「Double-Trap Exception」，以將意外異常傳遞給 M-mode 處理</p><p>之後會由 M-mode 接管處理該異常，期間 hart 會將該異常的資訊寫入對應的暫存器，但 <code>mcause</code> 和 <code>mtval2</code> 例外，<code>mtval2</code> 會存入「原本應該寫入 <code>mcause</code> 的值」，<code>mcause</code> 會被設為 <code>16</code>，代表這是一個 double-trap exception，好讓 M-mode 可以識別這是一個 S-mode 無法處理的異常</p><p>Trap handler 需要在儲存好 <code>scause</code>、<code>sepc</code>、<code>stval</code> 等狀態，並且可重入(reentrant) 後清除 <code>SDT</code> 位元，這表示在 Trap handler 的尾聲，如果在恢復系統狀態時又發生了新的異常，<code>SDT</code> 可以幫助 M-mode 檢測到這種情況</p><p>如果 guest OS 發生 page-fault，而這個異常觸發了 double trap，那麼當其被遞交到 M-mode 時，<code>mtval2</code> 暫存器將不會包含 Guest Physical Address (GPA)，這代表 Hypervisor 無法直接從 <code>mtval2</code> 取得 guest 的物理地址。 這會發生在 HS-mode 下執行虛擬機內的存取指令(load 或 store)，且</p><ul><li><code>SDT=1</code></li><li>該存取指令導致了 guest page-fault</li></ul><p>時，不過這不常發生。 另外，儘管 GPA 不會被記錄，但這沒關係，需要的話仍可以通過遍歷 page table 來達成目的</p><p>對於源自 VS-mode 的 double trap，M-mode 應該要將該異常重新導向到 HS-mode，具體做法是：</p><ul><li>將 M-mode 處理該異常時更新的 CSR 的值複製到 HS-mode 中對應的 CSR</li><li>使用 <code>MRET</code> 指令恢復執行，並從 <code>stvec</code> 指定的位址繼續執行</li></ul><p>SSE (Supervisor Software Events) 是 SBI (Supervisor Binary Interface) 的一項擴充，提供一種機制，使監督者軟體 (Supervisor Software) 能夠註冊 (register) 並處理 (service) 來自 SBI 實作的系統事件。 這些事件可能來自 SBI 內部，例如韌體或 Hypervisor</p><p>當發生 double trap 時，HS-mode 和 M-mode 可以使用 SSE 機制來啟動 critical-error handler 以處理對應的 VS-mode 或 S/HS-mode 中發生的異常。 此外，實作 SSE protocol 也可以做為一個選項，幫助系統從這類 critical errors 中恢復</p>',28))])}const v=c(p,[["render",Q],["__file","index.html.vue"]]),E=JSON.parse(`{"path":"/risc-v/Supervisor-Level-ISA/","title":"(WIP) Supervisor-Level ISA","lang":"en-US","frontmatter":{"title":"(WIP) Supervisor-Level ISA","date":"2025-02-25T00:00:00.000Z","tag":"risc-v","category":"risc-v","description":"12. Supervisor-Level ISA, Version 1.13 12.1.1. Supervisor Status (sstatus) Register sstatus 暫存器是一個 SXLEN-bit read/write 的暫存器，用來追蹤處理器目前的狀態，為 mstatus 的子集 當 SXLEN 為 32 時，格式如下圖： 當 S...","head":[["meta",{"property":"og:url","content":"https://mes0903.github.io/risc-v/Supervisor-Level-ISA/"}],["meta",{"property":"og:site_name","content":"Mes's Blog"}],["meta",{"property":"og:title","content":"(WIP) Supervisor-Level ISA"}],["meta",{"property":"og:description","content":"12. Supervisor-Level ISA, Version 1.13 12.1.1. Supervisor Status (sstatus) Register sstatus 暫存器是一個 SXLEN-bit read/write 的暫存器，用來追蹤處理器目前的狀態，為 mstatus 的子集 當 SXLEN 為 32 時，格式如下圖： 當 S..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"en-US"}],["meta",{"property":"og:updated_time","content":"2025-02-26T11:24:15.000Z"}],["meta",{"property":"article:tag","content":"risc-v"}],["meta",{"property":"article:published_time","content":"2025-02-25T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2025-02-26T11:24:15.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"(WIP) Supervisor-Level ISA\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2025-02-25T00:00:00.000Z\\",\\"dateModified\\":\\"2025-02-26T11:24:15.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Mes\\",\\"url\\":\\"https://mes0903.github.io\\"}]}"]]},"git":{"createdTime":1740417843000,"updatedTime":1740569055000,"contributors":[{"name":"Mes","username":"Mes","email":"mes900903@gmail.com","commits":3,"url":"https://github.com/Mes"}]},"readingTime":{"minutes":9.53,"words":2858},"filePathRelative":"risc-v/Supervisor-Level-ISA/README.md","localizedDate":"February 25, 2025","excerpt":"","autoDesc":true}`);export{v as comp,E as data};
